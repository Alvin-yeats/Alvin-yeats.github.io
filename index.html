<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Alvin&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Alvin&apos; Blog">
<meta property="og:type" content="website">
<meta property="og:title" content="Alvin's Blog">
<meta property="og:url" content="www.wyiren.com/index.html">
<meta property="og:site_name" content="Alvin's Blog">
<meta property="og:description" content="Alvin&apos; Blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Alvin's Blog">
<meta name="twitter:description" content="Alvin&apos; Blog">
  
    <link rel="alternative" href="/atom.xml" title="Alvin&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Alvin&#39;s Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Those that can，do. Those that can’t，complain.</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="www.wyiren.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-算法/1_1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/10/20/算法/1_1/" class="article-date">
  <time datetime="2015-10-20T08:42:06.596Z" itemprop="datePublished">2015-10-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/20/算法/1_1/">1. 从第一道面试题谈起</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
        <p>机构：博览GeekBand<br>讲师：董飞<br>更多详细内容请认真观看教学视频:)</p>
<ul>
<li>第一道题 </li>
<li>常见误区</li>
<li>面试官视角</li>
<li>自我反思</li>
</ul>
<h3 id="你需要了解的一些东西">你需要了解的一些东西</h3><ul>
<li>浏览器：<a href="https://www.google.com/webhp?hl=zh-CN" target="_blank" rel="external">谷歌</a></li>
<li>翻墙：<a href="https://www.google.com/search?q=%E6%80%8E%E4%B9%88%E7%BF%BB%E5%A2%99&amp;oq=%E6%80%8E%E4%B9%88%E7%BF%BB%E5%A2%99&amp;aqs=chrome..69i57j69i60l3j69i65j69i60.2444j0j4&amp;sourceid=chrome&amp;es_sm=122&amp;ie=UTF-8" target="_blank" rel="external">翻墙教程</a></li>
<li>工具：在线文档网站<a href="http://collabedit.com/" target="_blank" rel="external">collabedit</a></li>
</ul>
<h2 id="第一道题">第一道题</h2><ul>
<li>函数名：StrStr  </li>
<li>功能：在一个已有的字符串中寻找另一个字符串，如果找到返回起始地址，否则返回-1  </li>
<li>参考答案：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String source, String target)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (source == null || target == null) &#123;</span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> i, j;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; source.length() - target.length() + <span class="number">1</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; target.length(); j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (source.charAt(i + j) != target.charAt(j)) &#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (j == target.length()) &#123;</span><br><span class="line">				<span class="keyword">return</span> i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="常见误区">常见误区</h2><h3 id="StrStr常见问题1">StrStr常见问题1</h3><ul>
<li>装B失败</li>
<li>某些可能是科班出身的童鞋想到了高大上的<a href="https://zh.wikipedia.org/wiki/%E5%85%8B%E5%8A%AA%E6%96%AF-%E8%8E%AB%E9%87%8C%E6%96%AF-%E6%99%AE%E6%8B%89%E7%89%B9%E7%AE%97%E6%B3%95" target="_blank" rel="external">KMP算法</a></li>
<li>面试考察的是在有限的时间内实现题目的要求，太过复杂的算法可能让自己偷鸡不成蚀把米，也可能让某些面试官看不懂你的答案。</li>
</ul>
<h3 id="StrStr常见问题2">StrStr常见问题2</h3><ul>
<li>代码风格像坨shit</li>
<li>操作符与变量之间没有空格，for循环的分号后面也未空格，代码像黏在一起，影响阅读，一看就是新手菜鸟。</li>
</ul>
<h3 id="StrStr常见问题3">StrStr常见问题3</h3><ul>
<li>未考虑数组越界情况，例如在for循环中直接使用<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; src.lenth(); i++)</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; dest.length(); j++)</span><br><span class="line">		<span class="keyword">if</span> (src.charAt(i + j) != dest.charAt(j))</span><br><span class="line">			<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>i+j可能已经超过了src的范围；</p>
<h3 id="StrStr常见问题4">StrStr常见问题4</h3><p>Java：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; source.length() - target.length(); i++)</span><br></pre></td></tr></table></figure></p>
<p>循环条件中i的取值上限未+1</p>
<p>c++：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(source) - <span class="built_in">strlen</span>(target); i++)</span><br></pre></td></tr></table></figure></p>
<p>strlen的算法复杂度为O(n)级别，在c语言中strlen是使用指针来操作的，没有额外的空间来存储字符串数组的长度，直接使用会程序效率。可以考虑定义一个变量来存储strlen的值，然后再进行使用。</p>
<h3 id="求职者在面试中的常见误区">求职者在面试中的常见误区</h3><ol>
<li>认为做过的题（或者简单的题）肯定能过</li>
<li>算法想出来了就能过</li>
<li>代码写出来了就能过</li>
</ol>
<h2 id="面试官视角">面试官视角</h2><h3 id="面试官眼中的求职者：">面试官眼中的求职者：</h3><ol>
<li>你可能是他未来的同事</li>
<li>你的代码看起来舒服吗？<br>TA需要多少时间Review你的代码</li>
<li>你的Coding习惯良好吗？<br>TA不想在未来老是帮你DEBUG，你自己要是经常搞出事故咋办？编码规范参考：<a href="https://github.com/google/styleguide" target="_blank" rel="external">google coding style</a>/<a href="https://github.com/zh-google-styleguide/zh-google-styleguide" target="_blank" rel="external">Google开源项目风格指南(中文版)</a></li>
<li>你的沟通能力好吗？TA和你交流费劲吗？<br>日常会议讨论，口头沟通，文档</li>
</ol>
<h3 id="面试考察的编程基本功：">面试考察的编程基本功：</h3><ol>
<li>程序风格（缩进，括号，变量名）</li>
<li>Coding风格（异常检查，边界处理）</li>
<li>沟通（让面试官时刻明白你的意图）</li>
<li>测试（主动写出合理的Testcase）</li>
</ol>
<h2 id="自我反思">自我反思</h2><h3 id="你真的会面试吗？">你真的会面试吗？</h3><ol>
<li>你在做题之前，先在白纸上写一遍了吗？</li>
<li>写了200多题？你吃透了几个？</li>
<li>题目不会做要直接说自己不会吗？</li>
<li>是不是觉得面试官在为难你？</li>
</ol>
<h3 id="算法，永远的痛">算法，永远的痛</h3><ol>
<li>题做了很多，但就是记不住解法</li>
<li>从来就没有弄明白过动态规划是怎么回事</li>
<li>这题好像见过，不过还是不知道怎么做</li>
<li>leetcode，cc150都刷了，新题还是跪</li>
</ol>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="www.wyiren.com/2015/10/20/算法/1_1/" data-id="ciez04yxv000z5snugv91zkho" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/极客班/">极客班</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Java/javaconfiger" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/09/25/Java/javaconfiger/" class="article-date">
  <time datetime="2015-09-25T01:41:36.730Z" itemprop="datePublished">2015-09-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/25/Java/javaconfiger/">Windows下Java工作环境配置</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
        <h1 id="下载JDK">下载JDK</h1><ol>
<li>进入<a href="http://www.oracle.com/technetwork/java/index.html" target="_blank" rel="external">java官网</a>“java.oracle.com”;  </li>
<li>点击<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="external">Java SE</a>，在新弹出的页面中选择<a href="http://www.oracle.com/technetwork/java/javase/downloads/jre8-downloads-2133155.html" target="_blank" rel="external">JRE</a>进行下载：<br><img src="http://ww1.sinaimg.cn/mw690/89b29945gw1ewefoo3h7cj20bi05iab4.jpg" alt="SE"><br><img src="http://ww4.sinaimg.cn/mw690/89b29945gw1ewefonnfwyj20ff0a4q57.jpg" alt="JRE"> </li>
<li>首先勾选“Accept License Agreement”，然后选择相对应的系统（32位x86，64位x64），并选择exe后缀的文件进行下载；  </li>
<li>下载好之后点击exe文件等待自动安装完成即可； </li>
<li>大功告成。</li>
</ol>
<h1 id="IDE">IDE</h1><ol>
<li>在浏览器输入“eslipse.org”进入<a href="http://www.eclipse.org/" target="_blank" rel="external">eslipse官网</a>，点击右边的“DOWNLOAD”按钮进入下载页面；<br><img src="http://ww4.sinaimg.cn/mw690/89b29945gw1eweetafjp4j216v086wgh.jpg" alt="url"></li>
<li>选择“Eclipse IDE for Java Developers”相对应的系统位数进行下载；<br><img src="http://ww4.sinaimg.cn/mw690/89b29945gw1eweet9hn2pj20ns04d3ze.jpg" alt="bits"></li>
<li>选择靠近自己所在地的镜像进行下载；<br><img src="http://ww1.sinaimg.cn/mw690/89b29945gw1eweet9y2bsj209g08ot9g.jpg" alt="mirror"></li>
<li>解压；</li>
<li>进入解压目录，在eclipse目录下你会找到“eclipse.exe”，双击启动，开始java之路吧。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="www.wyiren.com/2015/09/25/Java/javaconfiger/" data-id="ciez04yxv00155snu9tcgq99l" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/环境配置/">环境配置</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-算法/3_3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/09/17/算法/3_3/" class="article-date">
  <time datetime="2015-09-17T07:11:13.519Z" itemprop="datePublished">2015-09-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/17/算法/3_3/">12. BFS与二叉搜索树</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
        <h2 id="Binary_Tree_BFS_Traversal">Binary Tree BFS Traversal</h2><p>二叉树层次遍历</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//刚开始没看懂，自己画图细看几遍发生特别精妙，赞一个</span></span><br><span class="line"><span class="comment">//一定要记住队列是先进先出的</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">levelTraversal</span><span class="params">(TreeNode *root)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode *&gt; nodeQueue;</span><br><span class="line">    TreeNode *currentNode;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先塞入根节点</span></span><br><span class="line">    nodeQueue.push(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!nodeQueue.empty()) &#123;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//当前节点值为queue中的第一个数据。</span></span><br><span class="line">        currentNode = nodeQueue.front();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//做进一步的处理，比如需要打印</span></span><br><span class="line">        processNode(currentNode);</span><br><span class="line">        <span class="keyword">if</span> (currentNode-&gt;left) &#123;</span><br><span class="line">            nodeQueue.push(currentNode-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (currentNode-&gt;right) &#123;</span><br><span class="line">            nodeQueue.push(currentNode-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//弹出当前的数据</span></span><br><span class="line">        nodeQueue.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Binary_Tree_to_Linked_Lists">Binary Tree to Linked Lists</h2><p>Covert a binary tree to linked lists. Each linked list is correspondent to all the nodes at the same level.</p>
<p>核心问题：如何判断这一层已经遍历完毕？</p>
<p>解题思路：利用优先队列</p>
<p>代码示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//为什么你老是喜欢把你定义的result写成answer，我真的要报警了</span></span><br><span class="line"></span><br><span class="line"><span class="function">ool <span class="title">isDummyNode</span><span class="params">(TreeNode *node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (node-&gt;left == node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">list</span>&lt;TreeNode *&gt;&gt; linkedListsFromTree(TreeNode *root) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">list</span>&lt;TreeNode *&gt;&gt; result;</span><br><span class="line">    <span class="built_in">list</span>&lt;TreeNode *&gt; levelList;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode *&gt; nodeQueue;</span><br><span class="line">    TreeNode *currentNode;</span><br><span class="line"></span><br><span class="line">    TreeNode dummyNode;</span><br><span class="line">    dummyNode.left = &amp;dummyNode;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nodeQueue.push(&amp;dummyNode);<span class="comment">//dummyNode用于分割层</span></span><br><span class="line">    nodeQueue.push(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!nodeQueue.empty()) &#123;</span><br><span class="line">        currentNode = nodeQueue.front();</span><br><span class="line">        <span class="keyword">if</span> (isDummyNode(currentNode)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!levelList.empty()) &#123;</span><br><span class="line"></span><br><span class="line">            	<span class="comment">//若首节点时dummyNode且level不为空，就将该level塞入我们的最终结果列表</span></span><br><span class="line">            	<span class="comment">//然后清空level。代表了一层遍历的结束，开始遍历二叉树的下一层</span></span><br><span class="line">                result.push_back(levelList);</span><br><span class="line">                levelList.clear();</span><br><span class="line">            &#125;</span><br><span class="line">            nodeQueue.pop();</span><br><span class="line">            <span class="keyword">if</span> (nodeQueue.empty()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            	<span class="comment">//每次遍历完一层，nodeQueue都会被塞入一个dummyNode</span></span><br><span class="line">                nodeQueue.push(&amp;dummyNode);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            levelList.push_back(currentNode);</span><br><span class="line">            <span class="keyword">if</span> (currentNode-&gt;left) &#123;</span><br><span class="line">                nodeQueue.push(currentNode-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (currentNode-&gt;right) &#123;</span><br><span class="line">                nodeQueue.push(currentNode-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            nodeQueue.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Binary_Tree_Level_Order_Traversal">Binary Tree Level Order Traversal</h3><ul>
<li>2 Queues</li>
<li>1 Queue + Dummy Node</li>
<li>1 Queue (best)</li>
</ul>
<p>示例代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// use 2 variables </span></span><br><span class="line"><span class="comment">//利用两个变量来判断一层是否遍历完，标志位为nodesInCurrentLevel，</span></span><br><span class="line"><span class="comment">//当其为0时一层遍历结束，输入endl换行</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printLevelOrder</span><span class="params">(BinaryTree *root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">queue</span>&lt;BinaryTree*&gt; nodesQueue;</span><br><span class="line">  <span class="keyword">int</span> nodesInCurrentLevel = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> nodesInNextLevel = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  nodesQueue.push(root);</span><br><span class="line">  <span class="keyword">while</span> (!nodesQueue.empty()) &#123;</span><br><span class="line">    BinaryTree *currNode = nodesQueue.front();</span><br><span class="line">    nodesQueue.pop();</span><br><span class="line">    nodesInCurrentLevel--;</span><br><span class="line">    <span class="keyword">if</span> (currNode) &#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; currNode-&gt;data &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">      nodesQueue.push(currNode-&gt;left);</span><br><span class="line">      nodesQueue.push(currNode-&gt;right);</span><br><span class="line">      nodesInNextLevel += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nodesInCurrentLevel == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">      nodesInCurrentLevel = nodesInNextLevel;</span><br><span class="line">      nodesInNextLevel = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// use 2 queue</span></span><br><span class="line"><span class="comment">//使用队列来判断，当currentLevel时一层遍历结束</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printLevelOrder</span><span class="params">(BinaryTree *root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">queue</span>&lt;BinaryTree*&gt; currentLevel, nextLevel;</span><br><span class="line">  currentLevel.push(root);</span><br><span class="line">  <span class="keyword">while</span> (!currentLevel.empty()) &#123;</span><br><span class="line">    BinaryTree *currNode = currentLevel.front();</span><br><span class="line">    currentLevel.pop();</span><br><span class="line">    <span class="keyword">if</span> (currNode) &#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; currNode-&gt;data &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">      nextLevel.push(currNode-&gt;left);</span><br><span class="line">      nextLevel.push(currNode-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (currentLevel.empty()) &#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">      swap(currentLevel, nextLevel);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Binary_Tree_Level_Order_Traversal_II">Binary Tree Level Order Traversal II</h3><p>Given a binary tree, return the bottom-up level order traversal of its nodes’values. (ie, from left to right, level by level from leaf to root).<br>For example: Given binary tree {3,9,20,#,#,15,7},</p>
<p><img src="http://ww4.sinaimg.cn/small/89b29945gw1euxt1k1tlrj203k03s3yg.jpg" alt="反式"></p>
<p>return its bottom-up level order traversal as:</p>
<p><img src="http://ww4.sinaimg.cn/small/89b29945gw1euxt1jcs4bj204n04gq2u.jpg" alt="反式1"></p>
<h2 id="Binary_Tree_Zigzag_Level_Order_Traversal">Binary Tree Zigzag Level Order Traversal</h2><p><a href="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/" target="_blank" rel="external">原题地址</a></p>
<p>示例代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printLevelOrderZigZag</span><span class="params">(BinaryTree *root)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">stack</span>&lt;BinaryTree*&gt; currentLevel, nextLevel;</span><br><span class="line">  <span class="keyword">bool</span> leftToRight = <span class="literal">true</span>;</span><br><span class="line">  currentLevel.push(root);</span><br><span class="line">  <span class="keyword">while</span> (!currentLevel.empty()) &#123;</span><br><span class="line">    BinaryTree *currNode = currentLevel.top();</span><br><span class="line">    currentLevel.pop();</span><br><span class="line">    <span class="keyword">if</span> (currNode) &#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; currNode-&gt;data &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">      <span class="keyword">if</span> (leftToRight) &#123;</span><br><span class="line">        nextLevel.push(currNode-&gt;left);</span><br><span class="line">        nextLevel.push(currNode-&gt;right);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        nextLevel.push(currNode-&gt;right);</span><br><span class="line">        nextLevel.push(currNode-&gt;left);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (currentLevel.empty()) &#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">      leftToRight = !leftToRight;</span><br><span class="line">      swap(currentLevel, nextLevel);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Binary_Search_Tree">Binary Search Tree</h2><p>二分查找树(Binary Search Tree, BST)是二叉树的一种特例，对于二分查找树的任意节点，该节点储存的数值一定比左子树的所有节点的值大比右子树的所有节点的值小(该节点储存的数值一定比左子树的所有节点的值小比右子树的所有节点的值大)。基于这个特性，二分查找树通常被用于维护有序数据。二分查找树查找、删除、插入的效率都会高于一般的线性数据结构。</p>
<p><img src="http://ww3.sinaimg.cn/mw690/89b29945gw1euxtdkikyyj20bn0azjro.jpg" alt="bst"></p>
<p>平衡二叉树的概念。所谓平衡二叉树，是指一棵树的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p>
<p>###有序数组变为二分查找树</p>
<p>代码示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;num, <span class="keyword">int</span> first, <span class="keyword">int</span> last)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(first &gt; last)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (first == last) &#123;</span><br><span class="line">        TreeNode* parent = <span class="keyword">new</span> TreeNode(num[first]);</span><br><span class="line">        <span class="keyword">return</span> parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (first + last) / <span class="number">2</span>;</span><br><span class="line">    TreeNode *leftchild = helper(num, first, mid - <span class="number">1</span>);</span><br><span class="line">    TreeNode *rightchild = helper(num, mid + <span class="number">1</span>, last);</span><br><span class="line">    TreeNode *parent = <span class="keyword">new</span> TreeNode(num[mid]);</span><br><span class="line">    parent-&gt;left = leftchild;</span><br><span class="line">    parent-&gt;right = rightchild;</span><br><span class="line">    <span class="keyword">return</span> parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode *<span class="title">sortedArrayToBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num.size() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(num.size() == <span class="number">1</span>)&#123;</span><br><span class="line">        TreeNode* parent = <span class="keyword">new</span> TreeNode(num[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> first = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> last = (<span class="keyword">int</span>)num.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> helper(num, first, last);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Is_Binary_Search_Tree">Is Binary Search Tree</h3><p>错误例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/************</span><br><span class="line">    10  </span><br><span class="line">    / \  </span><br><span class="line">    5 15  </span><br><span class="line">      / \  </span><br><span class="line">     6  20  </span><br><span class="line">*************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;left&amp;&amp;!root-&gt;right)</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root-&gt;left)&amp;&amp;(root-&gt;val&gt;root-&gt;left-&gt;val);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!root-&gt;left&amp;&amp;root-&gt;right)</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root-&gt;right)&amp;&amp;(root-&gt;val&lt;root-&gt;right-&gt;val);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;left&amp;&amp;root-&gt;right)</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root-&gt;left)&amp;&amp;isValidBST(root-&gt;right)&amp;&amp;(root-&gt;val&gt;root-&gt;left-&gt;val)&amp;&amp;(root-&gt;val&lt;root-&gt;right-&gt;val);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正确示例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(TreeNode *root, <span class="keyword">int</span> min, <span class="keyword">int</span> max)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>((root-&gt;val &lt; max || (root-&gt;val == INT_MAX &amp;&amp; root-&gt;right == <span class="literal">NULL</span>)) &amp;&amp;</span><br><span class="line">        (root-&gt;val &gt; min || (root-&gt;val == INT_MIN &amp;&amp; root-&gt;left == <span class="literal">NULL</span>)) &amp;&amp;</span><br><span class="line">        helper(root-&gt;left, min, root-&gt;val) &amp;&amp;</span><br><span class="line">        helper(root-&gt;right, root-&gt;val, max))</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> helper(root, INT_MIN, INT_MAX);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Trie">Trie</h2><p>字典树(trie or prefix tree)是一个26(26个英文字母)叉树，用于在一个集合中检索一个字符串，或者字符串前缀。字典树的每个节点有一个指针数组代表其所有子树，其本质上是一个hash table，因为子树所在的位置(index)本身，就代表了节点对应的字母。节点与每个兄弟具有相同的前缀，也被称为prefix tree。</p>
<h3 id="Trie_Structure">Trie Structure</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> TrieNode&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T mContent;</span><br><span class="line">    <span class="built_in">vector</span>&lt;TrieNode*&gt; mChildren;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Node();</span><br><span class="line">    ~Node();</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> Trie;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Trie&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Trie();</span><br><span class="line">    ~Trie();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addWord</span><span class="params">(<span class="built_in">string</span> s)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchWord</span><span class="params">(<span class="built_in">string</span> s)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteWord</span><span class="params">(<span class="built_in">string</span> s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TrieNode* root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Mock_Interview">Mock Interview</h2><h3 id="Lowest_Common_Ancestor(LCA)">Lowest Common Ancestor(LCA)</h3><p>最近的公共衔接点</p>
<p>Given a binary tree and two nodes. Find the lowest common ancestor of the two nodes in the tree.<br>For example, the LCA of D &amp; E is B.</p>
<p><img src="http://ww2.sinaimg.cn/mw690/89b29945gw1euxubtf12ej205g06d74a.jpg" alt="lca"></p>
<p>示例代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">TreeNode *<span class="title">commonAncestor</span><span class="params">(TreeNode *root, TreeNode *p, TreeNode *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (covers(root-&gt;left, p) &amp;&amp; covers(root-&gt;left, q)) &#123;</span><br><span class="line">        <span class="keyword">return</span> commonAncestor(root-&gt;left, q, p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (covers(root-&gt;right, p) &amp;&amp; covers(root-&gt;right, q)) &#123;</span><br><span class="line">        <span class="keyword">return</span> commonAncestor(root-&gt;right, q, p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">covers</span><span class="params">(TreeNode *root, TreeNode *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root == p) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> covers(root-&gt;left, p) || covers(root-&gt;right, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bottom to top</span></span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode *<span class="title">lowestCommonAncestor</span><span class="params">(TreeNode *root, TreeNode *A, TreeNode *B)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// return either A or B or NULL</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == root || root == A || root == B) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        TreeNode *left = lowestCommonAncestor(root-&gt;left, A, B);</span><br><span class="line">        TreeNode *right = lowestCommonAncestor(root-&gt;right, A, B);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// A and B are on both sides</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="literal">NULL</span> != left) &amp;&amp; (<span class="literal">NULL</span> != right)) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// either left or right or NULL</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">NULL</span> != left) ? left : right;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Homework:">Homework:</h2><p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</p>
<p>For example, this binary tree is symmetric:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/************</span><br><span class="line">     1  </span><br><span class="line">   /   \  </span><br><span class="line">  2     2  </span><br><span class="line"> / \   / \  </span><br><span class="line">3   4 4   3  </span><br><span class="line"></span><br><span class="line">************/</span></span><br></pre></td></tr></table></figure>
<p>But the following is not:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********</span><br><span class="line">  1  </span><br><span class="line"> / \  </span><br><span class="line"> 2  2  </span><br><span class="line">  \  \  </span><br><span class="line">   3  3  </span><br><span class="line"></span><br><span class="line">**********/</span></span><br></pre></td></tr></table></figure>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="www.wyiren.com/2015/09/17/算法/3_3/" data-id="ciez04ywk00005snu8lxhpabt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/极客班/">极客班</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-算法/3_2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/09/17/算法/3_2/" class="article-date">
  <time datetime="2015-09-17T07:11:08.158Z" itemprop="datePublished">2015-09-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/17/算法/3_2/">11. 分治算法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
        <p><a href="https://zh.wikipedia.org/wiki/%E5%88%86%E6%B2%BB%E6%B3%95" target="_blank" rel="external">分治算法</a>是将一个大问题分成几个小问题来进行处理</p>
<h2 id="Divide_&amp;_Conquer_Algorithm">Divide &amp; Conquer Algorithm</h2><ul>
<li>Merge Sort</li>
<li>Quick Sort</li>
<li>Most of the Binary Tree Problems!</li>
</ul>
<h3 id="Tree_Depth">Tree Depth</h3><p>Compute the depth of a binary tree.比较左右两边的深度</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">treeDepth</span><span class="params">(TreeNode *node)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> max(treeDepth(node-&gt;left),treeDepth(node-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Subtree">Subtree</h3><p>Tree1 and Tree2 are both binary trees nodes having value, determine if Tree2 is a subtree of Tree1.<br>判断root2是不是root1的子树</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">subTree</span><span class="params">(TreeNode *root1, TreeNode *root2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root2 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root1 == <span class="literal">NULL</span>) &#123; <span class="comment">//we have exhauste the root1 already</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root1-&gt;val == root2-&gt;val) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matchTree(root1, root2)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isSubTree(root1-&gt;left, root2) || isSubTree(root1-&gt;right, root2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">matchTree</span><span class="params">(TreeNode *root1, TreeNode *root2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root1 == <span class="literal">NULL</span> &amp;&amp; root2 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root1 == <span class="literal">NULL</span> || root2 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root1-&gt;val != root2-&gt;val) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> matchTree(root1-&gt;left, root2-&gt;left) &amp;&amp;</span><br><span class="line">        matchTree(root1-&gt;right, root2-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Balanced_Binary_Tree">Balanced Binary Tree</h3><p>Determine if a binary tree is a balanced tree.</p>
<p>一颗二叉树是平衡的，当且仅当左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p>
<p>当node为空的时候，高度为0，当node不为空的时候，高度为左、右子树中高度较高的那个的高度再加1</p>
<p>示例1：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">level</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root ==  <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> max(level(root-&gt;left), level(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root ==  <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> factor = <span class="built_in">abs</span>(level(root-&gt;left) - level(root-&gt;right));</span><br><span class="line">    <span class="keyword">return</span> factor &lt; <span class="number">2</span> &amp;&amp; isBalanced(root-&gt;right) &amp;&amp; isBalanced(root-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//缺点：重复计算较多</span></span><br></pre></td></tr></table></figure>
<p>示例2（改进版）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isBalancedHelper</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> leftHeight = isBalance(root-&gt;left);</span><br><span class="line">    <span class="keyword">if</span> (leftHeight == INBALANCE) &#123;</span><br><span class="line">        <span class="keyword">return</span> INBALANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> rightHeight = isBalance(root-&gt;right);</span><br><span class="line">    <span class="keyword">if</span> (rightHeight == INBALANCE) &#123;</span><br><span class="line">        <span class="keyword">return</span> INBALANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(leftHeight - rightHeight) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> INBALANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max(leftHeight, rightHeight) + <span class="number">1</span>;    <span class="comment">// return height</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalancedTree</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (isBalancedHelper(root) != INBALANCE)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Path_Sum">Path Sum</h3><p>Get all the paths (always starts from the root) in a binary tree, whose sum would be equal to given value.<br>从root开始，寻找路径value之和为给定sum的路径。</p>
<p>解题思路：使用递归，从root开始让sum不断地减去各个路径上节点的value，然后用于下次递归，直到某个节点值正好等于递减后的sum，我们便存储该路径。</p>
<p>示例代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//path：存储我们走过的具体路径</span></span><br><span class="line"><span class="comment">//result：存储符合条件的路径，可含多个</span></span><br><span class="line"><span class="comment">//root：根节点</span></span><br><span class="line"><span class="comment">//sum：给定的求和值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pathSumHelper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;result, TreeNode *root, <span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    path.push_back(root-&gt;val);</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;val == sum)&#123;</span><br><span class="line">        result.push_back(path);</span><br><span class="line">    &#125;</span><br><span class="line">    pathSumHelper(path, result, root-&gt;left, sum - root-&gt;val);</span><br><span class="line">    pathSumHelper(path, result, root-&gt;right, sum - root-&gt;val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; pathSum(TreeNode *root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">    pathSumHelper(path, result, root, sum);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Rebuild_Binary_Tree">Rebuild Binary Tree</h3><p>给你一个前序、中序字符串构建一个二叉树数据结构</p>
<p>示例代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//pstr:前序</span></span><br><span class="line"><span class="comment">//istr:中序</span></span><br><span class="line"><span class="comment">//n:所给字符串的长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// preorder and inorder rebuild</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">rebuild</span><span class="params">(<span class="keyword">char</span> *pstr, <span class="keyword">char</span> *istr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> TreeNode;</span><br><span class="line">    root-&gt;data = *pstr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* iter;</span><br><span class="line">    <span class="keyword">for</span> (iter = istr; iter &lt; istr + n; iter++) &#123;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//当中序遍历到前序首节点时（根节点）意味着找到了分割点</span></span><br><span class="line">        <span class="keyword">if</span> (*iter == *pstr)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k = iter - istr;</span><br><span class="line">    root-&gt;left = rebuild(pstr + <span class="number">1</span>, istr, k);</span><br><span class="line">    root-&gt;right = rebuild(pstr + k + <span class="number">1</span>, iter + <span class="number">1</span>, n - k - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="www.wyiren.com/2015/09/17/算法/3_2/" data-id="ciez04yx000055snusrisd49e" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/极客班/">极客班</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-算法/3_1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/09/17/算法/3_1/" class="article-date">
  <time datetime="2015-09-17T07:11:01.175Z" itemprop="datePublished">2015-09-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/17/算法/3_1/">10. 二叉树简介及先序、中序、后序</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
        <p>大纲：  </p>
<ol>
<li>二叉树介绍</li>
<li>先序/中序/后序 Preorder/inorder/postorder</li>
<li>分治算法 Divide &amp; Conquer</li>
<li>二叉树的宽度优先遍历</li>
<li>二叉树搜索树</li>
</ol>
<h2 id="翻转二叉树">翻转二叉树</h2><p>Homebrew作者Mark Howell面试被Google拒，因为不会翻转二叉树</p>
<p>（额……这也真够惨的……）</p>
<p><img src="http://ww3.sinaimg.cn/mw690/89b29945gw1euu4kxqnnjj209u04qjra.jpg" alt="翻转二叉树"></p>
<p><a href="https://leetcode.com/problems/invert-binary-tree/" target="_blank" rel="external">原题地址</a></p>
<p>解题思路：堆二叉树左右链表进行转换，是否有似曾相识的感觉？交换两个值的swap你一定写过吧，对的，就是它，我们将二叉树的左右假想为两个“特殊的值”，然后定义一个tmp用来储存一方交换值，然后交换他们即可，这里提到的“特殊的值”便是递归调用。  </p>
<p>示例代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">		TreeNode* tmpNode = root-&gt;left;</span><br><span class="line">		root-&gt;left = invertTree(root-&gt;right);</span><br><span class="line">		root-&gt;right = invertTree(tmpNode);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> root;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树">二叉树</h2><p>二叉树，是指对于树中的每个节点而言，至多有左右两个子节点，即任意节点的度小于等于2<br><img src="http://ww2.sinaimg.cn/mw690/89b29945gw1euu524cpqaj208j05v3yo.jpg" alt="二叉树"></p>
<h3 id="概念">概念</h3><ul>
<li>高度：从根节点到某个节点的路径长度称为该节点的层数(level)，根节点为第0层，非根节点的层数是其父节点的层数加1。树的高度定义为该树中层数最大的叶节点的层数加1，即相当于于从根节点到叶节点的最长路径加1。  </li>
<li>满二叉树(full binary tree)：如果一棵二叉树的任何结点，或者是叶节点，或者左右子树都存在，则这棵二叉树称作满二叉树。  </li>
<li>完全二叉树(complete binary tree)：如果一棵二叉树最多只有最下面的两层节点度数可以小于2，并且最下面一层的节点都集中在该层最左边的连续位置上，则此二叉树称作完全二叉树。  </li>
</ul>
<h3 id="Binary_Tree_DFS_Traversal">Binary Tree DFS Traversal</h3><p>Binary Tree Traversal</p>
<p><img src="http://ww2.sinaimg.cn/mw690/89b29945gw1euu5erylfij20hh083gm6.jpg" alt="二叉树遍历"></p>
<p>二叉树遍历中说的前中后序是以根节点为基准的，根节点在前则为前序遍历，在最后则为后序遍历，否则为中序遍历</p>
<h4 id="DFS代码">DFS代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrderTraversal</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!root) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	visit(root);</span><br><span class="line"></span><br><span class="line">	preOrderTraversal(root-&gt;left);</span><br><span class="line">	preOrderTraversal(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrderTraversal</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!root) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	inOrderTraversal(root-&gt;right);</span><br><span class="line">	visit(root);</span><br><span class="line">	inOrderTraversal(root-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrderTraversal</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!root) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	postOrderTraversal(root-&gt;left);</span><br><span class="line">	postOrderTraversal(root-&gt;right);</span><br><span class="line">	visit(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Traverse_Iteration">Traverse Iteration</h3><p>Stack: Preorder</p>
<p>示例代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">	LinkedList&lt;Node&gt; <span class="built_in">stack</span> = <span class="keyword">new</span> LinkedList&lt;Node&gt;();</span><br><span class="line">	Node pointer = root;</span><br><span class="line">	<span class="built_in">stack</span>.push(root);</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">stack</span>.isEmpty()) &#123;</span><br><span class="line">		pointer = <span class="built_in">stack</span>.pop();</span><br><span class="line">		System.out.print(pointer.data+<span class="string">", "</span>);</span><br><span class="line">		<span class="keyword">if</span>(pointer.rightChild != <span class="literal">NULL</span>)</span><br><span class="line">			<span class="built_in">stack</span>.push(pointer.rightChild);</span><br><span class="line">		<span class="keyword">if</span>(pointer.leftChild != <span class="literal">NULL</span>)</span><br><span class="line">			<span class="built_in">stack</span>.push(pointer.leftChild);</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.prinln();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://www.cnblogs.com/dolphin0520/archive/2011/08/25/2153720.html" target="_blank" rel="external">博文入口</a></p>
<h3 id="Find_Next_in_Binary_Tree">Find Next in Binary Tree</h3><p>In-order traverse a binary tree with parent links, find the next node to visit given a specific node.  </p>
<p><img src="http://ww3.sinaimg.cn/mw690/89b29945gw1eux8asckg2j207405xq31.jpg" alt="中序查找"></p>
<p>Followup: without parent link?</p>
<p>问题描述：一个按照中序遍历排列的二叉树，找到给定节点的下一个节点</p>
<p>代码示例：</p>
<p>遍历顺序均为“左、中、右”顺序</p>
<h4 id="当我们不知道根节点时">当我们不知道根节点时</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode *<span class="title">leftMostNode</span><span class="params">(TreeNode *node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (node-&gt;left) &#123;</span><br><span class="line">        node = node-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLeftChild</span><span class="params">(TreeNode *node, TreeNode *parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (parent-&gt;left == node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode *<span class="title">inOrderSuccessor</span><span class="params">(TreeNode *node)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//当给定节点为空时返回NULL</span></span><br><span class="line">    <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当给定节点的右子树存在时，返回右子树的左子树（如果左子树存在的话，否则返回给定节点的右子树）</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">        <span class="keyword">return</span> leftMostNode(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果是给定节点在根左子树的末尾，如上图中保存14的节点，那么就遍历返回到根节点</span></span><br><span class="line">    TreeNode *parent = node-&gt;parent;</span><br><span class="line">    <span class="keyword">while</span> (parent &amp;&amp; !isLeftChild(node, parent)) &#123;</span><br><span class="line">        node = parent;</span><br><span class="line">        parent = node-&gt;parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="当我们知道根节点时">当我们知道根节点时</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">TreeNode *<span class="title">inOrderSuccessor</span><span class="params">(TreeNode *node, TreeNode *root)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果存在右子树，返回右子树的左子树</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">        <span class="keyword">return</span> leftMostNode(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当root的值小于给定node值，但是下次开始大于node值时，</span></span><br><span class="line">    <span class="comment">//successor成功获取我们要寻找的下一个节点的值</span></span><br><span class="line">    TreeNode *successor = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &gt; node-&gt;val) &#123;</span><br><span class="line">            successor = root;</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> successor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="www.wyiren.com/2015/09/17/算法/3_1/" data-id="ciez04yx000085snutqkrw3bn" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/极客班/">极客班</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-算法/2_4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/09/17/算法/2_4/" class="article-date">
  <time datetime="2015-09-17T07:10:55.625Z" itemprop="datePublished">2015-09-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/17/算法/2_4/">9. 二分搜索扩展题型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
        <h2 id="Related_Questions">Related Questions</h2><ol>
<li>Rotate String: abcdefg, offset=3 -&gt; efgabcd  </li>
<li>Rotate Words List: I love you -&gt; you love I   </li>
</ol>
<p>Conclusion<br>Binary Search<br> – Exclude half every time<br>Sorted Array<br> – If array is sorted, try binary search<br> – If array is not sorted, try sort it first  </p>
<p>解题思路：针对1中的例子，先转置“abcd”为“dcba”，“efg”转置为“gfe”，此时string由“abcdefg”变为了“dcbagfe”，然后转置string得到“efgabcd”</p>
<p>示例代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"string.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Move the first n chars in a string to its end</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">LeftRotateString</span><span class="params">(<span class="keyword">char</span>* pStr, <span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pStr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> nLength = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="built_in">strlen</span>(pStr));</span><br><span class="line">        <span class="keyword">if</span>(nLength &gt; <span class="number">0</span> || n == <span class="number">0</span> || n &gt; nLength)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span>* pFirstStart = pStr;</span><br><span class="line">            <span class="keyword">char</span>* pFirstEnd = pStr + n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">char</span>* pSecondStart = pStr + n;</span><br><span class="line">            <span class="keyword">char</span>* pSecondEnd = pStr + nLength - <span class="number">1</span>;</span><br><span class="line">           </span><br><span class="line">            <span class="comment">// reverse the first part of the string</span></span><br><span class="line">            ReverseString(pFirstStart, pFirstEnd);</span><br><span class="line">            <span class="comment">// reverse the second part of the strint</span></span><br><span class="line">            ReverseString(pSecondStart, pSecondEnd);</span><br><span class="line">            <span class="comment">// reverse the whole string</span></span><br><span class="line">            ReverseString(pFirstStart, pSecondEnd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> pStr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reverse the string between pStart and pEnd</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReverseString</span><span class="params">(<span class="keyword">char</span>* pStart, <span class="keyword">char</span>* pEnd)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pStart == <span class="literal">NULL</span> || pEnd == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(pStart &lt;= pEnd)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> temp = *pStart;</span><br><span class="line">            *pStart = *pEnd;</span><br><span class="line">            *pEnd = temp;</span><br><span class="line">           </span><br><span class="line">            pStart ++;</span><br><span class="line">            pEnd --;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="算法效率测试">算法效率测试</h2><p>下面那长长一坨，有两百多行的代码是干嘛用的呢？</p>
<p>这段代码介绍了几种常见的反转算法，而且编写了一个可以计算算法执行时间的函数。  </p>
<p>输入接口：<br>algnum：你选的算法<br>numtests：测试次数<br>n：反转起始位置<br>rotdist：要反转的数据的长度  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Copyright (C) 1999 Lucent Technologies */</span></span><br><span class="line"><span class="comment">/* From 'Programming Pearls' by Jon Bentley */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* rotate.c -- time algorithms for rotating a vector</span><br><span class="line">    Input lines:</span><br><span class="line">        algnum numtests n rotdist</span><br><span class="line">        algnum:</span><br><span class="line">          1: reversal algorithm</span><br><span class="line">          2: juggling algorithm</span><br><span class="line">          22:  juggling algorithm with mod rather than if</span><br><span class="line">          3: gcd algorithm</span><br><span class="line">          4: slide (don't rotate): baseline alg for timing</span><br><span class="line">    To test the algorithms, recompile and change main to call testrot</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MAXN <span class="number">10000000</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x[MAXN];</span><br><span class="line"><span class="keyword">int</span> rotdist, n;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Alg 1: Rotate by reversal */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span><br><span class="line"></span>&#123;   <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        t = x[i]; x[i] = x[j]; x[j] = t;</span><br><span class="line">        i++;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">revrot</span><span class="params">(<span class="keyword">int</span> rotdist, <span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;   reverse(<span class="number">0</span>, rotdist-<span class="number">1</span>);</span><br><span class="line">    reverse(rotdist, n-<span class="number">1</span>);</span><br><span class="line">    reverse(<span class="number">0</span>, n-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Alg 2: Juggling (dolphin) rotation */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span><br><span class="line"></span>&#123;   <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">while</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j &gt;= i)</span><br><span class="line">            j -= i;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            t = i; i = j; j = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">jugglerot</span><span class="params">(<span class="keyword">int</span> rotdist, <span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;   <span class="keyword">int</span> cycles, i, j, k, t;</span><br><span class="line">    cycles = gcd(rotdist, n);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cycles; i++) &#123;</span><br><span class="line">        <span class="comment">/* move i-th values of blocks */</span></span><br><span class="line">        t = x[i];</span><br><span class="line">        j = i;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            k = j + rotdist;</span><br><span class="line">            <span class="keyword">if</span> (k &gt;= n)</span><br><span class="line">                k -= n;</span><br><span class="line">            <span class="keyword">if</span> (k == i)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            x[j] = x[k];</span><br><span class="line">            j = k;</span><br><span class="line">        &#125;</span><br><span class="line">        x[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">jugglerot2</span><span class="params">(<span class="keyword">int</span> rotdist, <span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;   <span class="keyword">int</span> cycles, i, j, k, t;</span><br><span class="line">    cycles = gcd(rotdist, n);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cycles; i++) &#123;</span><br><span class="line">        <span class="comment">/* move i-th values of blocks */</span></span><br><span class="line">        t = x[i];</span><br><span class="line">        j = i;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">          <span class="comment">/* Replace with mod below</span><br><span class="line">            k = j + rotdist;</span><br><span class="line">            if (k &gt;= n)</span><br><span class="line">                k -= n;</span><br><span class="line">           */</span></span><br><span class="line">            k = (j + rotdist) % n;</span><br><span class="line">            <span class="keyword">if</span> (k == i)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            x[j] = x[k];</span><br><span class="line">            j = k;</span><br><span class="line">        &#125;</span><br><span class="line">        x[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Alg 3: Recursive rotate (using gcd structure) */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span> <span class="comment">/* swap x[i..i+k-1] with x[j..j+k-1] */</span></span><br><span class="line"></span>&#123;   <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">while</span> (k-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        t = x[i]; x[i] = x[j]; x[j] = t;</span><br><span class="line">        i++;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gcdrot</span><span class="params">(<span class="keyword">int</span> rotdist, <span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;   <span class="keyword">int</span> i, j, p;</span><br><span class="line">    <span class="keyword">if</span> (rotdist == <span class="number">0</span> || rotdist == n)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    i = p = rotdist;</span><br><span class="line">    j = n - p;</span><br><span class="line">    <span class="keyword">while</span> (i != j) &#123;</span><br><span class="line">        <span class="comment">/* invariant:</span><br><span class="line">            x[0  ..p-i  ] is in final position</span><br><span class="line">            x[p-i..p-1  ] = a (to be swapped with b)</span><br><span class="line">            x[p  ..p+j-1] = b (to be swapped with a)</span><br><span class="line">            x[p+j..n-1  ] in final position</span><br><span class="line">        */</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; j) &#123;</span><br><span class="line">            swap(p-i, p, j);</span><br><span class="line">            i -= j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            swap(p-i, p+j-i, i);</span><br><span class="line">            j -= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(p-i, p, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isogcd</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span><br><span class="line"></span>&#123;   <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="keyword">return</span> j;</span><br><span class="line">    <span class="keyword">if</span> (j == <span class="number">0</span>) <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">while</span> (i != j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; j)</span><br><span class="line">            i -= j;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            j -= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testgcd</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;i, &amp;j) != EOF)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, isogcd(i,j) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Alg 4: slide (don't rotate): baseline alg for timing*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slide</span><span class="params">(<span class="keyword">int</span> rotdist, <span class="keyword">int</span> n)</span> <span class="comment">/* Benchmark: slide left rotdist (lose 0..rotdist-1) */</span></span><br><span class="line"></span>&#123;   <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = rotdist; i &lt; n; i++)</span><br><span class="line">        x[i-rotdist] = x[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Test all algs */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initx</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        x[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printx</span><span class="params">()</span></span><br><span class="line"></span>&#123;   <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" %d"</span>, x[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">roterror</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">" rotate bug %d %d\n"</span>, n, rotdist);</span><br><span class="line">    printx();</span><br><span class="line">    <span class="built_in">exit</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkrot</span><span class="params">()</span></span><br><span class="line"></span>&#123;   <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n-rotdist; i++)</span><br><span class="line">        <span class="keyword">if</span> (x[i] != i+rotdist)</span><br><span class="line">            roterror();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; rotdist; i++)</span><br><span class="line">        <span class="keyword">if</span> (x[n-rotdist+i] != i)</span><br><span class="line">            roterror();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testrot</span><span class="params">()</span></span><br><span class="line"></span>&#123;   <span class="keyword">for</span> (n = <span class="number">1</span>; n &lt;= <span class="number">20</span>; n++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" testing n=%d\n"</span>, n);</span><br><span class="line">        <span class="keyword">for</span> (rotdist = <span class="number">0</span>; rotdist &lt;= n; rotdist++) &#123;</span><br><span class="line">            <span class="comment">/* printf("  testing rotdist=%d\n", rotdist); */</span></span><br><span class="line">            initx(); revrot(rotdist, n);     checkrot();</span><br><span class="line">            initx(); jugglerot(rotdist, n);  checkrot();</span><br><span class="line">            initx(); jugglerot2(rotdist, n); checkrot();</span><br><span class="line">            initx(); gcdrot(rotdist, n);     checkrot();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Timing */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timedriver</span><span class="params">()</span></span><br><span class="line"></span>&#123;   <span class="keyword">int</span> i, algnum, numtests, start, clicks;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>, &amp;algnum, &amp;numtests, &amp;n, &amp;rotdist) != EOF) &#123;</span><br><span class="line">        initx();</span><br><span class="line">        start = clock();</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numtests; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (algnum == <span class="number">1</span>)</span><br><span class="line">                revrot(rotdist, n);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (algnum == <span class="number">2</span>)</span><br><span class="line">                jugglerot(rotdist, n);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (algnum == <span class="number">22</span>)</span><br><span class="line">                jugglerot2(rotdist, n);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (algnum == <span class="number">3</span>)</span><br><span class="line">                gcdrot(rotdist, n);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (algnum == <span class="number">4</span>)</span><br><span class="line">                slide(rotdist, n);</span><br><span class="line">        &#125;</span><br><span class="line">        clicks = clock() - start;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\t%d\t%d\t%d\t%d\t%g\n"</span>,</span><br><span class="line">            algnum, numtests, n, rotdist, clicks,</span><br><span class="line">            <span class="number">1e9</span>*clicks/((<span class="keyword">float</span>) CLOCKS_PER_SEC*n*numtests));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Main */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;   <span class="comment">/* testrot(); */</span></span><br><span class="line">    timedriver();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="www.wyiren.com/2015/09/17/算法/2_4/" data-id="ciez04yx0000b5snugqmx50uu" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/极客班/">极客班</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-算法/2_3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/09/17/算法/2_3/" class="article-date">
  <time datetime="2015-09-17T07:10:46.347Z" itemprop="datePublished">2015-09-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/17/算法/2_3/">8. 排序数组常见算法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
        <p>前几个题比较简单，最后一个合并K个有序数组，不熟悉STL模板的童鞋可能会抓狂，不要紧，我已经添加了详细的注释，只要认真看下去认真思考，相信你可以的！</p>
<h2 id="Remove_Duplicates_from_Sorted_Array_I,II">Remove Duplicates from Sorted Array I,II</h2><p>对有序数组去重  </p>
<h3 id="每个元素只能出现一次">每个元素只能出现一次</h3><p><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="external">Remove Duplicates from Sorted Array I</a>  </p>
<p>问题描述：给你一个排好序的数组，去掉重复的元素保证每个元素只出现一次。不允许使用另外一个数组来提供额外的空间，你必须在原数组中进行这个工作。</p>
<p>解题思路：董老师这里运用了fast,low两个值，只有当下一个元素与上一个唯一元素不重复时slow才加1，slow实际存储的去重后新数组的长度，而fast是用来遍历数组的，当fast超过数组的size时，即意味着遍历结束，我们的去重工作完成。由于原题要求不允许使用额外的空间，所以下面的解法是直接对已重复的元素所在地址进行覆盖，后面的会被直接移到前面。</p>
<p>示例代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line">Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.</span><br><span class="line">Do not allocate extra space for another array, you must do this in place with constant memory.</span><br><span class="line">For example,</span><br><span class="line">Given input array A = [1,1,2],</span><br><span class="line">Your function should return length = 2, and A is now [1,2].</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = A.length;</span><br><span class="line">        <span class="keyword">if</span> (size &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> size;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> fast = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ( fast &lt; size) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[slow] != A[fast]) &#123;</span><br><span class="line">                A[slow+<span class="number">1</span>] = A[fast];</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="如果我们允许每个元素可以出现至少两次呢？">如果我们允许每个元素可以出现至少两次呢？</h3><p><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/" target="_blank" rel="external">Remove Duplicates from Sorted Array II</a></p>
<p>很简单，我们加个标志位来记录元素的重复次数就好了，当重复次数超过两次时我们再进行去重处理。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line">Follow up for "Remove Duplicates":</span><br><span class="line">What if duplicates are allowed at most twice?</span><br><span class="line">For example,</span><br><span class="line">Given sorted array A = [1,1,1,2,2,3],</span><br><span class="line">Your function should return length = 5, and A is now [1,1,2,2,3].</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Start typing your Java solution below</span></span><br><span class="line">        <span class="comment">// DO NOT write main() function</span></span><br><span class="line">        <span class="keyword">int</span> size = A.length;</span><br><span class="line">        <span class="keyword">if</span> (size &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> size;</span><br><span class="line">        <span class="keyword">int</span> fast = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dup = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ( fast &lt; size) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[slow] != A[fast]) &#123;</span><br><span class="line">                A[slow+<span class="number">1</span>] = A[fast];</span><br><span class="line">                slow++;</span><br><span class="line">                dup = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                dup++;</span><br><span class="line">                <span class="keyword">if</span> (dup &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                    A[slow+<span class="number">1</span>] = A[fast];</span><br><span class="line">                    slow++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Intersection_of_2_sorted_array">Intersection of 2 sorted array</h2><p>在有序数组中找交集：   </p>
<pre><code>array1:[<span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">6</span>]  
array2:[<span class="number">3</span> <span class="number">6</span> <span class="number">9</span> <span class="number">10</span>]  

<span class="keyword">return</span> [<span class="number">3</span>,<span class="number">6</span>]
</code></pre><p>解题思路：遍历比较A、B两数组中的元素，如果出现相等的元素便将该值加入到新的数组中。无疑，用vector这种动态容器来充当新数组是最好的。</p>
<p>示例代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findIntersection(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; B) &#123;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intersection;</span><br><span class="line">  <span class="keyword">int</span> n1 = A.size();</span><br><span class="line">  <span class="keyword">int</span> n2 = B.size();</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; n1 &amp;&amp; j &lt; n2) &#123;</span><br><span class="line">      <span class="keyword">if</span> (A[i] &gt; B[j]) &#123;</span><br><span class="line">          j++;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (B[j] &gt; A[i]) &#123;</span><br><span class="line">          i++;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          intersection.push_back(A[i]);</span><br><span class="line">          i++;</span><br><span class="line">          j++;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> intersection;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Merge_Sorted_Array">Merge Sorted Array</h2><p>合并有序数组</p>
<p>1.Merge Two Sorted Array into a new Array<br>2.Merge Two Sorted Array A and B into A, assume A has enough space.</p>
<p>解题思路：董老师的程序是将组合后的新元素塞到了数组B里面。大致思路就是我们要想让B成为合并后的新数组，就必须确保B多余的空间大于等于A数组的长度，所以下面代码给A定了n的长度，而B为2*n。B从第n位开始都初始化为0，意味着后面是可以用来被重新赋值覆盖的。在填充新的数组B的时候，为了不将前面的元素覆盖，我们从后往前填充数组。</p>
<p>示例代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Set A[n] = &#123;<span class="number">2</span>, <span class="number">11</span>, <span class="number">54</span>, <span class="number">87</span>, <span class="number">99</span>&#125;</span><br><span class="line">Set B[<span class="number">2</span>*n] = = &#123;<span class="number">4</span>, <span class="number">9</span>, <span class="number">34</span>, <span class="number">67</span>, <span class="number">98</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> B[], <span class="keyword">int</span> size_b,  <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    indexA=n -<span class="number">1</span>;</span><br><span class="line">    indexB=n -<span class="number">1</span>;</span><br><span class="line">    index_new=<span class="number">2</span>n -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (index_new &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[indexA] &lt; B[indexB]) &#123;</span><br><span class="line">            B[index_new] = B[indexB];</span><br><span class="line">            indexB--;</span><br><span class="line">            index_new--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            B[index_new] = A[indexA];</span><br><span class="line">            indexA--;</span><br><span class="line">            index_new--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Optimization if A or B can be directly copied</span></span><br><span class="line">        <span class="comment">//如果B原有的元素为空，那么直接像B中填充即可</span></span><br><span class="line">        <span class="keyword">if</span> (indexB == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span>(index_new &gt;= <span class="number">0</span>)</span><br><span class="line">                B[index_new--] = A[indexA--];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果A为空，那没必要合并了</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (indexA == -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Merge_K_Sorted_List">Merge K Sorted List</h2><p>Merge k sorted linked lists to be one sorted list.</p>
<p>在该题中，董老师用到了<a href="http://www.cplusplus.com/reference/queue/priority_queue/" target="_blank" rel="external">优先队列</a>，这里我简单介绍下它的概念。</p>
<p>priority_queue的模板声明带有三个参数:<br>priority_queue<type, container,="" functional=""><br>其中Type 为数据类型， Container 为保存数据的容器，Functional 为元素比较方式。<br>Container必须是用数组实现的容器，比如 vector, deque 但不能用 list.<br>STL里面默认用的是 vector. 比较方式默认用 operator&lt; , 所以如果你把后面俩个参数缺省的话，优先队列就是大顶堆，队头元素最大。</type,></p>
<p>优先队列中元素出队列的顺序由元素的优先级决定，而不是元素进入队列的次序 ，</p>
<p>例如：我们常用的操作就是对数据排序，优先队列默认的是数据大的优先级高，所以我们无论按照什么顺序push一堆数，最终在队列里总是top出最大的元素。</p>
<p>这里需要重点说明的是当你使用priority_queue来push数据的时候，你录入的数据并不会进行排序，只有当你pop数据的时候，priority_queue才会根据Functional规定的数据优先级来弹出优先级最高的那个数据。</p>
<p>解题思路：利用<a href="https://zh.wikipedia.org/wiki/%E6%9C%80%E5%A4%A7%E2%80%94%E6%9C%80%E5%B0%8F%E5%A0%86" target="_blank" rel="external">最小堆</a>这种数据结构，我们首先把k个链表的首元素都加入最小堆中，它们会自动排好序。然后我们每次取出最小的那个元素加入我们最终结果的链表中，然后把刚刚被取出元素的那个链表的下一个元素再加入堆中，下次仍从堆中取出最小的元素做相同的操作，以此类推，直到堆中没有元素了，此时k个链表也合并为了一个链表，返回首节点即可，注意head(存储最终结果的链表头)跟heap(最小堆)不要混淆。</p>
<p>示例代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> ListNode &#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x) : val(x), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//重载操作符，定义优先级为数据越小优先级越大</span></span><br><span class="line"><span class="keyword">struct</span> cmp &#123;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> ListNode *a, <span class="keyword">const</span> ListNode *b)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a-&gt;val &lt; b-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode *<span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode *&gt; &amp;lists)</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;ListNode *, <span class="built_in">vector</span>&lt;ListNode *&gt;, cmp&gt; heap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将每个链表中的头结点（即每个数组开头最小的值）压入堆中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lists.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lists[i]) &#123;</span><br><span class="line">            <span class="comment">// for the corner case: [&#123;&#125;]</span></span><br><span class="line">            heap.push(lists[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode *prevNode = <span class="literal">NULL</span>;</span><br><span class="line">    ListNode *head = <span class="literal">NULL</span>;</span><br><span class="line">    ListNode *curNode = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不但pop最小堆中的数据，并将那个数据填入到新链表中</span></span><br><span class="line">    <span class="comment">//直到堆中数据为空，停止循环</span></span><br><span class="line">    <span class="keyword">while</span> (!heap.empty()) &#123;</span><br><span class="line">    	<span class="comment">//curNode始终代表了堆中最小的那个数据节点</span></span><br><span class="line">        curNode = heap.top();</span><br><span class="line">        heap.pop();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一次循环，head指向了堆中最小的数据</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            head = curNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果那个最小的数据所在的链表后面还有数据，那就将他后面的数据压入堆中</span></span><br><span class="line">        <span class="keyword">if</span> (curNode-&gt;next) &#123;</span><br><span class="line">            heap.push(curNode-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义前一个节点用于新链表的迭代更新，</span></span><br><span class="line">        <span class="comment">//第二次prevNode已存在，curNode（新的最小数据）会被接入到prevNode的后面，链表在不断地被填入新的数据</span></span><br><span class="line">        <span class="keyword">if</span> (prevNode) &#123;</span><br><span class="line">            prevNode-&gt;next = curNode;</span><br><span class="line">        &#125;</span><br><span class="line">        prevNode = curNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回我们新链表的头结点，合并K个数组工作完成</span></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="www.wyiren.com/2015/09/17/算法/2_3/" data-id="ciez04yx0000e5snu6fseru5y" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/极客班/">极客班</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-算法/2_2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/09/17/算法/2_2/" class="article-date">
  <time datetime="2015-09-17T07:10:39.851Z" itemprop="datePublished">2015-09-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/17/算法/2_2/">7. 二分搜索模板及变体（下）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
        <h2 id="矩阵搜索升级版">矩阵搜索升级版</h2><p>这个代码很巧妙，相比原来的那个<a href="https://github.com/Alvin-yeats/Algorithm_GeekBand/blob/master/chapter2/2_1.md#矩阵搜索" target="_blank" rel="external">矩阵搜索</a>更像是真正意义上的二分查找，亮点就是upper值得初始化和数组下标迭代更新。</p>
<p>实验了下发现董飞老师的示例代码是错误的，while循环内matrix下标应为“[mid/n][mid%n]”，而非“[mid%m][mid%n]”  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Start typing your Java solution below</span></span><br><span class="line">        <span class="comment">// DO NOT write main() function</span></span><br><span class="line">        <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (target &lt; matrix[<span class="number">0</span>][<span class="number">0</span>] || target &gt; matrix[m-<span class="number">1</span>][n-<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> lower = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> upper = m*n -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (lower &lt;= upper) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = lower + (upper-lower)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (target == matrix[mid/n][mid%n]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; matrix[mid/n][mid%n]) &#123;</span><br><span class="line">                upper = mid-<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lower = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Find_Peak_Element">Find Peak Element</h2><p><a href="https://leetcode.com/problems/find-peak-element/" target="_blank" rel="external">原题地址</a><br>A peak element is an element that is greater than its neighbors.<br>For example, in array [1, 2, 3, 1], 3 is a peak element and your function should return the index number 2.</p>
<p>找到数组中的峰点，即这个数大于左右两边的数，示例代码如下。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// A divide and conquer solution to find a peak element element</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A binary search based function that returns index of a peak element</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findPeakUtil</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">// Find index of middle element</span></span><br><span class="line">    <span class="keyword">int</span> mid = low + (high - low)/<span class="number">2</span>;  <span class="comment">/* (low + high)/2 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compare middle element with its neighbours (if neighbours exist)</span></span><br><span class="line">    <span class="keyword">if</span> ((mid == <span class="number">0</span> || arr[mid-<span class="number">1</span>] &lt;= arr[mid]) &amp;&amp;</span><br><span class="line">            (mid == n-<span class="number">1</span> || arr[mid+<span class="number">1</span>] &lt;= arr[mid]))</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If middle element is not peak and its left neighbor is greater than it</span></span><br><span class="line">    <span class="comment">// then left half must have a peak element</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mid &gt; <span class="number">0</span> &amp;&amp; arr[mid-<span class="number">1</span>] &gt; arr[mid])</span><br><span class="line">        <span class="keyword">return</span> findPeakUtil(arr, low, (mid -<span class="number">1</span>), n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If middle element is not peak and its right neighbor is greater than it</span></span><br><span class="line">    <span class="comment">// then right half must have a peak element</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> findPeakUtil(arr, (mid + <span class="number">1</span>), high, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A wrapper over recursive function findPeakUtil()</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findPeak</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> findPeakUtil(arr, <span class="number">0</span>, n-<span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Driver program to check above functions */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">20</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Index of a peak point is %d"</span>, findPeak(arr, n));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="www.wyiren.com/2015/09/17/算法/2_2/" data-id="ciez04yx0000h5snuj4peb5te" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/极客班/">极客班</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-算法/2_1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/09/17/算法/2_1/" class="article-date">
  <time datetime="2015-09-17T07:10:29.967Z" itemprop="datePublished">2015-09-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/17/算法/2_1/">6. 二分搜索模板及其变体（上）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
        <h2 id="前言">前言</h2><p>我们先来看下<a href="https://zh.wikipedia.org/wiki/%E6%8A%98%E5%8D%8A%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95" target="_blank" rel="external">二分搜索维基解释</a>  </p>
<blockquote>
<ul>
<li>在计算机科学中，折半搜索（英语：half-interval search），也称二分查找算法（binary search）、二分搜索法、二分搜索、二分探索，是一种在有序数组中查找某一特定元素的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。  </li>
</ul>
</blockquote>
<p>我个人比较喜欢读作“二分查找”。<br>这里讲点二分查找的概念准备：<br>二分查找主要解决“在一堆数中找出指定值的位置”这类问题。<br>由此我们可以得出以下结论，要想应用二分查找，这一堆数必须满足以下特征：</p>
<ul>
<li>存储在数组中</li>
<li>有序排列</li>
</ul>
<p>所以如果是用链表存储的，将无法应用二分查找。（有的面试官会问：二分查找用什么数据结构？数组还是链表？）<br>至于“有序排列”是递增还是递减，数组中是否存在相同元素，这些都不重要。不过一般情况，我们会希望数组是递增排列，且数组中的元素互不相同。</p>
<h2 id="如何做二分搜索">如何做二分搜索</h2><p>如果您认真看了前言中附的二分查找基本概念，基本思路应该有了，而且我相信很多报班的小伙伴之前已经听过甚至自己实现过。<br>这里先讲个关于“二分查找”的有趣小故事  </p>
<blockquote>
<p>二分查找可以解决（预排序数组的查找）问题：只要数组中包含T（即要查找的值），那么通过不断缩小包含T的范围，最终就可以找到它。一开始，范围覆盖整个数组。将数组的中间项与T进行比较，可以排除一半元素，范围缩小一半。就这样反复比较，反复缩小范围，最终就会在数组中找到T，或者确定原以为T所在的范围实际为空。对于包含N个元素的表，整个查找过程大约要经过log(2)N次比较。  </p>
<p>多数程序员都觉得只要理解了上面的描述，写出代码就不难了；但事实并非如此。如果你不认同这一点，最好的办法就是放下书本，自己动手写一写。试试吧。  </p>
<p>我在贝尔实验室和IBM的时候都出过这道考题。那些专业的程序员有几个小时的时间，可以用他们选择的语言把上面的描述写出来；写出高级伪代码也可以。考试结束后，差不多所有程序员都认为自己写出了正确的程序。于是，我们花了半个钟头来看他们编写的代码经过测试用例验证的结果。几次课，一百多人的结果相差无几：90%的程序员写的程序中有bug（我并不认为没有bug的代码就正确）。</p>
<p>我很惊讶：在足够的时间内，只有大约10%的专业程序员可以把这个小程序写对。但写不对这个小程序的还不止这些人：高德纳在《计算机程序设计的艺术 第3卷 排序和查找》第6.2.1节的“历史与参考文献”部分指出，虽然早在1946年就有人将二分查找的方法公诸于世，但直到1962年才有人写出没有bug的二分查找程序。</p>
<p>——乔恩·本特利，《编程珠玑（第1版）》第35-36页。</p>
</blockquote>
<p>下面我们来动手写一下看看这传说中干掉90%程序员的二分查找到底如何</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//[参考鸣谢](http://blog.csdn.net/v_july_v/article/details/7093204)</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> *<span class="built_in">array</span>, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> value)</span>  </span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (left&lt;=right)          <span class="comment">//循环条件，适时而变  </span></span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">int</span> middle = left + (right-left)/<span class="number">2</span>;  <span class="comment">//使用“(left + right) / 2”可能会造成栈溢出  </span></span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">array</span>[middle]&gt;value)  </span><br><span class="line">        &#123;  </span><br><span class="line">            right =middle-<span class="number">1</span>;   <span class="comment">//right赋值，适时而变  </span></span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">array</span>[middle]&lt;value)  </span><br><span class="line">        &#123;  </span><br><span class="line">            left=middle+<span class="number">1</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">            <span class="keyword">return</span> middle;    </span><br><span class="line">        <span class="comment">//可能会有读者认为刚开始时就要判断相等，但毕竟数组中不相等的情况更多  </span></span><br><span class="line">        <span class="comment">//如果每次循环都判断一下是否相等，将耗费时间  </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>乍看之下也就区区十来行代码，但是其中有很多要容易犯错的细节，童鞋们需要特别注意注释中提到的要点以及middle值的设定。</p>
<h2 id="使用递归的二分搜索模板">使用递归的二分搜索模板</h2><p>简单粗暴，直接show code</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> *<span class="built_in">array</span>, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> value)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mid = left + (left + right)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (arrary[mid] == value) &#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">array</span>[mid]&gt; value) &#123;</span><br><span class="line">        <span class="keyword">return</span>    binarySearch(<span class="built_in">array</span>, left, mid -<span class="number">1</span>, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">array</span>[mid]&lt; value) &#123;</span><br><span class="line">        <span class="keyword">return</span>    binarySearch(<span class="built_in">array</span>, mid+<span class="number">1</span>, right, value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="A_generic_binary_search_template">A generic binary search template</h2><p>汗，看到这个标题以为董老师要写C++模板，结果……<br>还是我自己来吧  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//模板源码</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;T&gt; &amp;<span class="built_in">array</span>,T value)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = <span class="built_in">array</span>.size() -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ( left &lt;= right )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> middle = left + ( right - left ) /<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> ( <span class="built_in">array</span>[middle] == value )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( <span class="built_in">array</span>[middle] &gt; value )</span><br><span class="line">        &#123;</span><br><span class="line">            right = middle - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( <span class="built_in">array</span>[middle] &lt; value )</span><br><span class="line">        &#123;</span><br><span class="line">            left = middle + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//在vs下进行简单测试，通过</span></span><br><span class="line"><span class="comment">//你可以改变数组的大小或者value的大小来进行更多的测试</span></span><br><span class="line"><span class="comment">//如有更多问题请联系我email:alvinyeats@gmail.com</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;   </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;<span class="number">20</span>;i++)</span><br><span class="line">        <span class="built_in">array</span>.push_back(i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> status = binarySearch&lt;<span class="keyword">int</span>&gt;(<span class="built_in">array</span>, value);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; status &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Search_Insert_Position">Search Insert Position</h2><p><a href="https://leetcode.com/problems/search-insert-position/" target="_blank" rel="external">leetcode原题地址</a><br>Given a sorted array and a target value, return the index<br> the target is found. If not, return the index where it would be if it were inserted in order.<br>You may assume no duplicates in the array.</p>
<p>没啥可说的，经过上面的洗礼，做这个题应该感觉很简单  </p>
<p>示例代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> e32`<span class="number">123451</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.size()-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Invariant: the desired index is between [low, high+1]</span></span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + (high-low)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">                low = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                high = mid-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (1) At this point, low &gt; high. That is, low &gt;= high+1</span></span><br><span class="line">        <span class="comment">// (2) From the invariant, we know that the index is between [low, high+1], so low &lt;= high+1. Follwing from (1), now we know low == high+1.</span></span><br><span class="line">        <span class="comment">// (3) Following from (2), the index is between [low, high+1] = [low, low], which means that low is the desired index</span></span><br><span class="line">        <span class="comment">//     Therefore, we return low as the answer. You can also return high+1 as the result, since low == high+1</span></span><br><span class="line">        <span class="keyword">return</span> low;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Search_in_Rotated_Sorted_Array">Search in Rotated Sorted Array</h2><p>在轮转后的有序数组上应用二分查找<br><a href="https://leetcode.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="external">leetcode原题地址</a><br>Suppose a sorted array is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).</p>
<p>You are given a target value to search. If found in the array return its index, otherwise return -1.</p>
<p>You may assume no duplicate exists in the array.</p>
<p>该题要注意的地方是：判断给定值到底属于前面的区间{4,5,6,7}还是后面的区间{0,1,2}<br>这种数组并不是严格的递增排列，所以我们先比较M与L(也可以比较M与R，道理是一样的)，然后相对应的来判断要查找的key值是否位于[L,M]区间，或是[M,R]区间，从而确定下一步究竟是减小R还是增大M</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rotated_binary_search</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> N, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> R = N - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (L &lt;= R) &#123;</span><br><span class="line">    <span class="comment">// Avoid overflow, same as M=(L+R)/2</span></span><br><span class="line">    <span class="keyword">int</span> M = L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (A[M] == key) <span class="keyword">return</span> M;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the bottom half is sorted</span></span><br><span class="line">    <span class="keyword">if</span> (A[L] &lt;= A[M]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[L] &lt;= key &amp;&amp; key &lt; A[M])</span><br><span class="line">            R = M - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            L = M + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the upper half is sorted</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[M] &lt; key &amp;&amp; key &lt;= A[R])</span><br><span class="line">            L = M + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            R = M - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>扩展：<a href="https://leetcode.com/problems/search-in-rotated-sorted-array-ii/" target="_blank" rel="external">Search in Rotated Sorted Array II</a><br>有兴趣的童鞋可以试下。</p>
<h2 id="Find_the_Square_Root">Find the Square Root</h2><p>利用二分法找到一个数的平方根。<br>董老师的例程就很不错，我就不自己写了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//函数功能</span></span><br><span class="line"><span class="comment">//输入：待求平方根的数n</span></span><br><span class="line"><span class="comment">//输出：误差允许范围内n的平方根</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">squareRoot</span><span class="params">(<span class="keyword">float</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> x = n;</span><br><span class="line">    <span class="keyword">float</span> y = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">float</span> e = <span class="number">0.000001</span>;  <span class="comment">//e decides the accuracy level</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(x - y &gt; e)</span><br><span class="line">    &#123;</span><br><span class="line">        x = (x + y)/<span class="number">2</span>;</span><br><span class="line">        y = n/x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="矩阵搜索">矩阵搜索</h2><p>题目描述：Check if an element is in a M*N matrix, each row and column of which is sorted.</p>
<p>有题目可知，这个矩阵的每行每列都是排好序的，也就是说每行每列是递增（或递减，请自行分析）的。<br>我们简单构造这样一个矩阵：<br>1   5   10   20<br>2   6   11   30<br>7   9   12   40<br>8   15  31   41  </p>
<p>利用这个矩阵的特性我们可以运用二分查找的思想来简化这个问题<br>解决方法：不用递归，从矩阵的右上角(x,y)开始search（这样有一个好处：(x,y)的左侧所有点都小于matrxi[x][y], （x,y）的下侧所有点都大于matrix[x][y]），在每个点都做这样的判断：<br>示例代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isElementInMatrix</span><span class="params">(<span class="keyword">int</span> **matrix, <span class="keyword">int</span> M, <span class="keyword">int</span> N, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> column = N - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (row &lt; M &amp;&amp; column &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix[row][column] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (matrix[row][column] &lt; target) &#123;</span><br><span class="line">            row++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            column--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Range_Search">Range Search</h2><p>Given a sorted array of intergers with duplicates.Implement a function to get the start and end position of a given value.</p>
<p>有时我们并不是要寻找目标值，而是寻找到“刚刚”大于给定值的值或者“刚刚”小于给定值的值。<br>用数学方式描述就是：在原集合中寻找包含目标值区间的最小子集</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">searchRangeHelper</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> target, <span class="keyword">int</span> &amp;begin, <span class="keyword">int</span> &amp;end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = right - (right - left) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">array</span>[mid] == target) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mid &lt; begin || begin == -<span class="number">1</span>) &#123;</span><br><span class="line">            begin = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mid &gt; end) &#123;</span><br><span class="line">            end = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        searchRangeHelper(<span class="built_in">array</span>, left, mid - <span class="number">1</span>, target, begin, end);</span><br><span class="line">        searchRangeHelper(<span class="built_in">array</span>, mid + <span class="number">1</span>, right, target, begin, end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">array</span>[mid] &lt; target) &#123;</span><br><span class="line">        searchRangeHelper(<span class="built_in">array</span>, mid + <span class="number">1</span>, right, target, begin, end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        searchRangeHelper(<span class="built_in">array</span>, left, mid - <span class="number">1</span>, target, begin, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; searchRange(<span class="keyword">int</span> A[], <span class="keyword">int</span> n, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">int</span> begin = -<span class="number">1</span>, end = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    searchRangeHelper(A, <span class="number">0</span>, n - <span class="number">1</span>, target, begin, end);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    ans.push_back(begin);</span><br><span class="line">    ans.push_back(end);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="www.wyiren.com/2015/09/17/算法/2_1/" data-id="ciez04yxg000k5snu3acsg03j" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/极客班/">极客班</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-算法/1_5" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/09/17/算法/1_5/" class="article-date">
  <time datetime="2015-09-17T07:10:13.630Z" itemprop="datePublished">2015-09-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/17/算法/1_5/">5. 链表常见操作</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
        <p>推荐大家看下<a href="http://book.douban.com/subject/3004255/" target="_blank" rel="external">《编程之美》</a>、<a href="http://book.douban.com/subject/25753386/" target="_blank" rel="external">《程序员面试金典》</a><br>还有编程相关网站：<a href="https://leetcode.com/problemset/algorithms/" target="_blank" rel="external">leetcode</a><br>老师讲的很多题其实就是这些书和网站的题</p>
<h2 id="单链表是否存在环？环的入口是什么？">单链表是否存在环？环的入口是什么？</h2><h3 id="是否存在环">是否存在环</h3><p>1) 判断是否存在环：设置快慢指针fast和slow，fast步速为2，slow为1，若最终fast==slow，那么就证明单链表中一定有环。如果没有环的话，fast一定先到达尾节点</p>
<p>2) 简单证明：利用相对运动的概念，以slow为参考点（静止不动），那么fast的步速实际为1，当fast超过slow之后，fast以每步一个节点的速度追赶slow，如果链表有环的话，fast一定会追赶到slow，即fast==slow。</p>
<h3 id="如何找到环的入口">如何找到环的入口</h3><p><img src="http://ww4.sinaimg.cn/mw690/89b29945gw1eurmxod4q0j20eq09tjs5.jpg" alt="第一次相遇"></p>
<p>字母代表的量：  </p>
<ul>
<li>a：链表头结点到环入口的距离  </li>
<li>r：环长</li>
<li>蓝色线：fast指针所走的距离2s  </li>
<li>黑色线：slow指针所走的距离s</li>
</ul>
<p>假设链表总长度为L，且fast与slow相遇时fast已经绕环走了n圈，则有如下关系：</p>
<p>2s = s + n<em>r<br>将s移到左边得：<br>s = n</em>r<br>转换：<br>s = (n-1)<em>r + r = (n-1)</em>r + L-a<br>a+x = (n-1)<em>r + L-a<br>得：<br>a = (n-1)</em>r + L-a-x</p>
<p>由图可知，（L-a-x）为相遇点到环入口点的距离。由上式可知：<br>从链表头到环入口的距离 = （n-1）圈内环循环 + 相遇点到环入口点的距离<br>将r视为周期的话，a与L-a-x在某种意义上是相等的（实际并不一定相等）。<br>那么由此我们便找到了突破点，为了找到环的入口点，在fast与slow相遇时，将slow指针重新指向单链表的头节点，fast仍然留在相遇点，只不过步速降为与slow相同的1，每次循环只经过一个节点，如此，当fast与slow再次相遇时，那个新的相遇点便是我们苦苦寻找的入口点了。</p>
<h3 id="如何知道环的长度">如何知道环的长度</h3><p>纪录下相遇点，让slow与fast从该点开始，再次碰撞所走过的操作数就是环的长度r。  </p>
<h3 id="带环的链表的长度是多少？">带环的链表的长度是多少？</h3><p>通过以上分析我们已经知道了如何求环入口，环长，那么链表长度显然就是两者之和，即：<br>L = a + r</p>
<h2 id="判断两个链表是否相交">判断两个链表是否相交</h2><p>分析问题之前我们要搞清楚链表相交的一些基本概念  </p>
<ul>
<li>明确概念：两个单向链表相交，只能是y型相交，不可能是x型相交。  </li>
<li>分析：有两个链表，La,Lb,设他们的交点设为p，假设在La中，p的前驱为pre_a，后继为next_a,在Lb中，前驱为pre_b,后继为next_b，则<br>pre_a-&gt;next=p,pre_b-&gt;next=p,接下来看后继,p-&gt;next=next_a,p-&gt;next=next_b；那么问题就出来了，一个单链表的next指针只有一个，<br>怎么跑出两个来呢，所以必有next_a==next_b，于是我们得出两个链表相交只能是Y型相交。明确了这个概念，我们再来堆相交问题进行分析。</li>
</ul>
<h3 id="情况一：两个链表都无环">情况一：两个链表都无环</h3><p>1) 问题简化。将链表B接到链表A的后面，如果A、B有交点，则构成一个有环的单链表，而我们刚刚在上面已经讨论了如何判断一个<br>单链表是否有环。<br>2) 若两个链表相交则必为Y型，由此可知两个链表从相交点到尾节点是相同的，我们并不知道他们的相交点位置，但是我们可以遍历得出A、B链表的<br>尾节点，如此，比较他们的尾节点是否相等便可以求证A、B是否相交了。</p>
<h3 id="情况二：链表有环">情况二：链表有环</h3><p>1) 其中一个链表有环，另外一个链表无环。则两个链表不可能相交。（啥？你不知道为啥？自己看看前面的“明确概念”反省吧）</p>
<p>2) 那么有环相交的情况只有当两个链表都有环时才会出现，如果两个有环链表相交，则他们拥有共通的环，即环上任意一个节点都存在于<br>两个链表上。因此，通过判断A链表上的快慢指针相遇点是否也在B链表上便可以得出两个链表是否相交了。</p>
<h2 id="求相交链表的相交点">求相交链表的相交点</h2><p>题目描述：如果两个无环单向链表相交，怎么求出他们相交的第一个节点呢？</p>
<p>分析：采用对齐的思想。计算两个链表的长度 L1 , L2，分别用两个指针 p1 , p2 指向两个链表的头，然后将较长链表的 p1（假设为 p1）向后移动L2 - L1个节点，然后再同时向后移动p1 , p2，直到 p1 = p2。相遇的点就是相交的第一个节点。</p>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="www.wyiren.com/2015/09/17/算法/1_5/" data-id="ciez04yxg000n5snua4grk78j" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/极客班/">极客班</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-算法/1_3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/09/17/算法/1_3/" class="article-date">
  <time datetime="2015-09-17T07:09:49.255Z" itemprop="datePublished">2015-09-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/17/算法/1_3/">3. 工具和经验谈</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
        <h2 id="工具介绍">工具介绍</h2><ul>
<li><a href="https://windows.github.com/" target="_blank" rel="external">GitHub for Windows</a>,<a href="https://mac.github.com/" target="_blank" rel="external">GitHub for Mac</a>社区版的git，拥有全球最大的同性交友平台的美称</li>
<li><a href="https://git-scm.com/downloads" target="_blank" rel="external">git</a>分布式版本控制和软件配置管理软件</li>
<li><a href="http://www.sublimetext.com/" target="_blank" rel="external">Sublime</a>功能强大颜值超高的编辑器，谁用谁知道</li>
<li><a href="https://en.wikipedia.org/wiki/Computer_terminal" target="_blank" rel="external">Terminal</a>终端机，程序员应该都懂得，学习下怎么用快捷键打开你电脑上的终端吧</li>
<li>g++：先在这玩意儿很多Linux都带的有，如果没有你就在终端敲入“apt-get install g++”，Window下推荐使用<a href="https://www.visualstudio.com/en-us/downloads/download-visual-studio-vs.aspx" target="_blank" rel="external">Visual Stadio</a>，实在想用g++可以下个<a href="http://sourceforge.net/projects/mingw-w64/?source=recommended" target="_blank" rel="external">MinGW for Windows</a>玩玩</li>
<li><a href="http://mooc.study.163.com/learn/ZJU-1000002014?tid=1000002010#/learn/content?type=detail&amp;id=1000013004&amp;cid=1000013008" target="_blank" rel="external">Java</a>安装，我认为网易云课堂Java老师翁凯讲的就特别好，前段时间同学还跟我说装java老是失败……然后我就说你可以去看看翁凯老师讲的安装java的教程，过来人表示，选错教程真心害死人</li>
</ul>
<h2 id="常见问题">常见问题</h2><p>没带耳机，戴耳机了再详细填坑</p>
<ul>
<li>应届生招聘VS非应届生招聘</li>
<li>准备时间少？基础少？怎么刷题更高效？</li>
<li>转行找CS怎么准备？</li>
<li>面试的时候怎么表现自己（or 怎么沟通）</li>
<li>动态规划完全不懂怎么办？</li>
<li>面试写出了BUG怎么办？</li>
</ul>
<h2 id="推荐书籍">推荐书籍</h2><ul>
<li><a href="http://book.douban.com/subject/3072383/" target="_blank" rel="external">The Algorithm Design Manual</a>,<a href="http://www3.cs.stonybrook.edu/~algorith/video-lectures/" target="_blank" rel="external">作者的上课视频</a></li>
<li>大部头<a href="http://book.douban.com/subject/3904676/" target="_blank" rel="external">Introduction to Algorithm</a>,<a href="http://book.douban.com/subject/1418402/" target="_blank" rel="external">TAOCP</a></li>
<li><a href="http://book.douban.com/subject/10436668/" target="_blank" rel="external">Cracking The Coding Interview</a>屌爆侠CTCI（又称CC150）写的书，准备北美面试的同学必看</li>
<li><a href="http://book.douban.com/subject/6966465/" target="_blank" rel="external">剑指Offer</a>，适合国内找工作</li>
<li><a href="http://www.amazon.cn/%E8%BF%9B%E5%86%9B%E7%A1%85%E8%B0%B7-%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8F%AD%E7%A7%98-%E9%99%88%E4%B8%9C%E9%94%8B/dp/B00IXBJXGA/ref=sr_1_1?ie=UTF8&amp;qid=1438824440&amp;sr=8-1&amp;keywords=%E8%BF%9B%E5%86%9B%E7%A1%85%E8%B0%B7-%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8F%AD%E7%A7%98" target="_blank" rel="external">进军硅谷-程序员面试揭秘</a>，有差不多150题，大部分是leetcode上的</li>
</ul>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="www.wyiren.com/2015/09/17/算法/1_3/" data-id="ciez04yxv000t5snus9hq9v8x" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/极客班/">极客班</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-算法/1_2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/09/17/算法/1_2/" class="article-date">
  <time datetime="2015-09-17T07:09:49.240Z" itemprop="datePublished">2015-09-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/17/算法/1_2/">2. 面试中的算法模版</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
        <p>书：cracking the coding interview <a href="http://book.douban.com/subject/10436668/" target="_blank" rel="external">豆瓣</a> <a href="http://www.amazon.cn/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8-%E9%BA%A6%E5%85%8B%E9%81%93%E5%B0%94/dp/B00G8VOQOG/ref=sr_1_cc_1?s=aps&amp;ie=UTF8&amp;qid=1437569486&amp;sr=1-1-catcorr&amp;keywords=Cracking+the+Coding+Interview" target="_blank" rel="external">亚马逊</a><br>网站：<a href="http://www.careercup.com/" target="_blank" rel="external">careercup</a></p>
<h2 id="代码风格">代码风格</h2><p>代码块可分为三大块：异常处理（空串和边界处理），主体，返回值  </p>
<p>代码风格（可参考Google的编程语言规范）  </p>
<ul>
<li>变量名的命名（有意义的变量名）</li>
<li>缩进（语句块）</li>
<li>空格（运算符两边）</li>
<li>代码可读性（即使if语句只有一句也要加花括号）</li>
</ul>
<p>《代码大全》中给出的参考</p>
<h2 id="基本代码素养">基本代码素养</h2><ul>
<li>关于空格<br>for，if，else，while等记得加空格符<br>用空行把大块代码分成逻辑上的“段落”</li>
<li>关于括号<br>c指针中的指针符靠近类型名，如写成int<em> p，而不写成int </em>p<br>一个函数只专注做一件事</li>
<li>关于命名<br><a href="https://zh.wikipedia.org/wiki/%E9%A7%9D%E5%B3%B0%E5%BC%8F%E5%A4%A7%E5%B0%8F%E5%AF%AB" target="_blank" rel="external">驼峰写法</a></li>
</ul>
<h2 id="实战算法策略">实战算法策略</h2><ul>
<li>总结归类相似题目</li>
<li>找出适合同一类题目的模板程序</li>
<li>对基础题熟练掌握</li>
</ul>
<h2 id="再看一道简单题">再看一道简单题</h2><h3 id="Memmove">Memmove</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memmove</span><span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">const</span> <span class="keyword">void</span> *src, size_t n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">// implementation here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="陷阱">陷阱</h3><ul>
<li>内存重叠的处理</li>
<li>临时变量太多或者没有安全释放</li>
<li>没有测试内存越界</li>
<li>指针操作不熟悉</li>
</ul>
<h3 id="正确写法">正确写法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memmove</span><span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">const</span> <span class="keyword">void</span> *src, size_t n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *p1 = dest;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *p2 = src;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (p2 &lt; p1) &#123;</span><br><span class="line">		p2 += n;</span><br><span class="line">		p1 += n;</span><br><span class="line">		<span class="keyword">while</span> (n-- != <span class="number">0</span>)</span><br><span class="line">			*--p1 = *--p2;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">while</span> (n-- != <span class="number">0</span>)</span><br><span class="line">			*p1++ = *p2++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="排列组合模板">排列组合模板</h2><h3 id="Subsets">Subsets</h3><p>{1,2,3}<br>{ {},{1},{2},{3},{1,2},{1,3},{2,3},{1,2,3} }<br>转化为程序问题  </p>
<h4 id="Subsets-1">Subsets</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">subsets</span><span class="params">(<span class="keyword">int</span>[] num)</span> </span>&#123;</span><br><span class="line">	ArrayList&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">	Arrays.sort(num);</span><br><span class="line">	subsetsHelper(path, num, <span class="number">0</span>);	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">subsetsHelper</span><span class="params">(ArrayList&lt;Integer&gt; path, <span class="keyword">int</span>[] num, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">	outputToResult(path);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = pos; i &lt; num.length; i++) &#123;</span><br><span class="line">		path.add(num[i]);</span><br><span class="line">		subsetsHelper(path, num, i + <span class="number">1</span>);</span><br><span class="line">		path.remove(path.size() - <span class="number">1</span>);	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Subsets-Sample">Subsets-Sample</h4><p>对递归图的理解</p>
<h3 id="Unique_Subsets">Unique Subsets</h3><p>{1,2,2}<br>{ {},{1},{2},{1,2},{2,2},{1,2,2} }</p>
<h4 id="Unique_Subsets-1">Unique Subsets</h4><ul>
<li>与Subsets有关，先背下Subsets的模板  </li>
<li>既然要求Unique的，就想办法排除掉重复的。  </li>
<li>思考哪些情况会重复？如{1,2(1),2(2),2(3)}，规定{1,2(1)}和{1,2(2)}重复，{1,2(1),2(2)}和{1,2(2),2(3)}重复。观察规律。  </li>
<li>得出规律：我们只关心取多少个2，不关心取哪几个。</li>
<li>规定必须从第一个2开始连续取（作为重复集合中的代表），如必须是{1,2(1)}不能是{1,2(2)}  </li>
<li>将这个逻辑转换为程序语言去判断</li>
</ul>
<h3 id="Unique_Permutations">Unique Permutations</h3><p>[1,2,2]<br>[1,2,2],[2,1,2],[2,2,1]</p>
<h3 id="排列组合模板总结">排列组合模板总结</h3><ul>
<li>使用范围<br>几乎所有的搜索问题</li>
<li>根据具体题目要求进行改动<br>什么时候输出<br>哪些情况需要跳过</li>
</ul>
<h3 id="使用该模板的题目">使用该模板的题目</h3><ul>
<li>Combination Sum</li>
<li>Letter Combination of a Phone Number</li>
<li>Palindrome Partitioning</li>
<li>Restore IP Address</li>
</ul>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="www.wyiren.com/2015/09/17/算法/1_2/" data-id="ciez04yxv000w5snuw8hmv0hq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/极客班/">极客班</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</section>
        
          <aside id="sidebar">
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/极客班/">极客班</a><span class="tag-list-count">12</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/环境配置/">环境配置</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a><span class="tag-list-count">12</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Java/" style="font-size: 10px;">Java</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/极客班/" style="font-size: 20px;">极客班</a> <a href="/tags/环境配置/" style="font-size: 10px;">环境配置</a> <a href="/tags/算法/" style="font-size: 20px;">算法</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">十月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">九月 2015</a><span class="archive-list-count">13</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2015/10/20/算法/1_1/">1. 从第一道面试题谈起</a>
          </li>
        
          <li>
            <a href="/2015/09/25/Java/javaconfiger/">Windows下Java工作环境配置</a>
          </li>
        
          <li>
            <a href="/2015/09/17/算法/3_3/">12. BFS与二叉搜索树</a>
          </li>
        
          <li>
            <a href="/2015/09/17/算法/3_2/">11. 分治算法</a>
          </li>
        
          <li>
            <a href="/2015/09/17/算法/3_1/">10. 二叉树简介及先序、中序、后序</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2015 Alvin Yeats<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>