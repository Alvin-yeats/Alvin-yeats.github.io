<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Alvin&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Alvin&apos; Blog">
<meta property="og:type" content="website">
<meta property="og:title" content="Alvin's Blog">
<meta property="og:url" content="www.wyiren.com/page/2/index.html">
<meta property="og:site_name" content="Alvin's Blog">
<meta property="og:description" content="Alvin&apos; Blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Alvin's Blog">
<meta name="twitter:description" content="Alvin&apos; Blog">
  
    <link rel="alternative" href="/atom.xml" title="Alvin&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Alvin&#39;s Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Don’t Dissect the Frog，Build It</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="www.wyiren.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-算法/3_3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/09/16/算法/3_3/" class="article-date">
  <time datetime="2015-09-16T08:07:45.514Z" itemprop="datePublished">2015-09-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/16/算法/3_3/">3.3 BFS与二叉搜索树</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Binary_Tree_BFS_Traversal">Binary Tree BFS Traversal</h2><p>二叉树层次遍历</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//刚开始没看懂，自己画图细看几遍发生特别精妙，赞一个</span></span><br><span class="line"><span class="comment">//一定要记住队列是先进先出的</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">levelTraversal</span><span class="params">(TreeNode *root)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode *&gt; nodeQueue;</span><br><span class="line">    TreeNode *currentNode;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先塞入根节点</span></span><br><span class="line">    nodeQueue.push(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!nodeQueue.empty()) &#123;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//当前节点值为queue中的第一个数据。</span></span><br><span class="line">        currentNode = nodeQueue.front();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//做进一步的处理，比如需要打印</span></span><br><span class="line">        processNode(currentNode);</span><br><span class="line">        <span class="keyword">if</span> (currentNode-&gt;left) &#123;</span><br><span class="line">            nodeQueue.push(currentNode-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (currentNode-&gt;right) &#123;</span><br><span class="line">            nodeQueue.push(currentNode-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//弹出当前的数据</span></span><br><span class="line">        nodeQueue.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Binary_Tree_to_Linked_Lists">Binary Tree to Linked Lists</h2><p>Covert a binary tree to linked lists. Each linked list is correspondent to all the nodes at the same level.</p>
<p>核心问题：如何判断这一层已经遍历完毕？</p>
<p>解题思路：利用优先队列</p>
<p>代码示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//为什么你老是喜欢把你定义的result写成answer，我真的要报警了</span></span><br><span class="line"></span><br><span class="line"><span class="function">ool <span class="title">isDummyNode</span><span class="params">(TreeNode *node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (node-&gt;left == node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">list</span>&lt;TreeNode *&gt;&gt; linkedListsFromTree(TreeNode *root) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">list</span>&lt;TreeNode *&gt;&gt; result;</span><br><span class="line">    <span class="built_in">list</span>&lt;TreeNode *&gt; levelList;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode *&gt; nodeQueue;</span><br><span class="line">    TreeNode *currentNode;</span><br><span class="line"></span><br><span class="line">    TreeNode dummyNode;</span><br><span class="line">    dummyNode.left = &amp;dummyNode;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nodeQueue.push(&amp;dummyNode);<span class="comment">//dummyNode用于分割层</span></span><br><span class="line">    nodeQueue.push(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!nodeQueue.empty()) &#123;</span><br><span class="line">        currentNode = nodeQueue.front();</span><br><span class="line">        <span class="keyword">if</span> (isDummyNode(currentNode)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!levelList.empty()) &#123;</span><br><span class="line"></span><br><span class="line">            	<span class="comment">//若首节点时dummyNode且level不为空，就将该level塞入我们的最终结果列表</span></span><br><span class="line">            	<span class="comment">//然后清空level。代表了一层遍历的结束，开始遍历二叉树的下一层</span></span><br><span class="line">                result.push_back(levelList);</span><br><span class="line">                levelList.clear();</span><br><span class="line">            &#125;</span><br><span class="line">            nodeQueue.pop();</span><br><span class="line">            <span class="keyword">if</span> (nodeQueue.empty()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            	<span class="comment">//每次遍历完一层，nodeQueue都会被塞入一个dummyNode</span></span><br><span class="line">                nodeQueue.push(&amp;dummyNode);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            levelList.push_back(currentNode);</span><br><span class="line">            <span class="keyword">if</span> (currentNode-&gt;left) &#123;</span><br><span class="line">                nodeQueue.push(currentNode-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (currentNode-&gt;right) &#123;</span><br><span class="line">                nodeQueue.push(currentNode-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            nodeQueue.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Binary_Tree_Level_Order_Traversal">Binary Tree Level Order Traversal</h3><ul>
<li>2 Queues</li>
<li>1 Queue + Dummy Node</li>
<li>1 Queue (best)</li>
</ul>
<p>示例代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// use 2 variables </span></span><br><span class="line"><span class="comment">//利用两个变量来判断一层是否遍历完，标志位为nodesInCurrentLevel，</span></span><br><span class="line"><span class="comment">//当其为0时一层遍历结束，输入endl换行</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printLevelOrder</span><span class="params">(BinaryTree *root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">queue</span>&lt;BinaryTree*&gt; nodesQueue;</span><br><span class="line">  <span class="keyword">int</span> nodesInCurrentLevel = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> nodesInNextLevel = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  nodesQueue.push(root);</span><br><span class="line">  <span class="keyword">while</span> (!nodesQueue.empty()) &#123;</span><br><span class="line">    BinaryTree *currNode = nodesQueue.front();</span><br><span class="line">    nodesQueue.pop();</span><br><span class="line">    nodesInCurrentLevel--;</span><br><span class="line">    <span class="keyword">if</span> (currNode) &#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; currNode-&gt;data &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">      nodesQueue.push(currNode-&gt;left);</span><br><span class="line">      nodesQueue.push(currNode-&gt;right);</span><br><span class="line">      nodesInNextLevel += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nodesInCurrentLevel == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">      nodesInCurrentLevel = nodesInNextLevel;</span><br><span class="line">      nodesInNextLevel = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// use 2 queue</span></span><br><span class="line"><span class="comment">//使用队列来判断，当currentLevel时一层遍历结束</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printLevelOrder</span><span class="params">(BinaryTree *root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">queue</span>&lt;BinaryTree*&gt; currentLevel, nextLevel;</span><br><span class="line">  currentLevel.push(root);</span><br><span class="line">  <span class="keyword">while</span> (!currentLevel.empty()) &#123;</span><br><span class="line">    BinaryTree *currNode = currentLevel.front();</span><br><span class="line">    currentLevel.pop();</span><br><span class="line">    <span class="keyword">if</span> (currNode) &#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; currNode-&gt;data &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">      nextLevel.push(currNode-&gt;left);</span><br><span class="line">      nextLevel.push(currNode-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (currentLevel.empty()) &#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">      swap(currentLevel, nextLevel);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Binary_Tree_Level_Order_Traversal_II">Binary Tree Level Order Traversal II</h3><p>Given a binary tree, return the bottom-up level order traversal of its nodes’values. (ie, from left to right, level by level from leaf to root).<br>For example: Given binary tree {3,9,20,#,#,15,7},</p>
<p><img src="http://ww4.sinaimg.cn/small/89b29945gw1euxt1k1tlrj203k03s3yg.jpg" alt="反式"></p>
<p>return its bottom-up level order traversal as:</p>
<p><img src="http://ww4.sinaimg.cn/small/89b29945gw1euxt1jcs4bj204n04gq2u.jpg" alt="反式1"></p>
<h2 id="Binary_Tree_Zigzag_Level_Order_Traversal">Binary Tree Zigzag Level Order Traversal</h2><p><a href="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/" target="_blank" rel="external">原题地址</a></p>
<p>示例代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printLevelOrderZigZag</span><span class="params">(BinaryTree *root)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">stack</span>&lt;BinaryTree*&gt; currentLevel, nextLevel;</span><br><span class="line">  <span class="keyword">bool</span> leftToRight = <span class="literal">true</span>;</span><br><span class="line">  currentLevel.push(root);</span><br><span class="line">  <span class="keyword">while</span> (!currentLevel.empty()) &#123;</span><br><span class="line">    BinaryTree *currNode = currentLevel.top();</span><br><span class="line">    currentLevel.pop();</span><br><span class="line">    <span class="keyword">if</span> (currNode) &#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; currNode-&gt;data &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">      <span class="keyword">if</span> (leftToRight) &#123;</span><br><span class="line">        nextLevel.push(currNode-&gt;left);</span><br><span class="line">        nextLevel.push(currNode-&gt;right);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        nextLevel.push(currNode-&gt;right);</span><br><span class="line">        nextLevel.push(currNode-&gt;left);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (currentLevel.empty()) &#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">      leftToRight = !leftToRight;</span><br><span class="line">      swap(currentLevel, nextLevel);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Binary_Search_Tree">Binary Search Tree</h2><p>二分查找树(Binary Search Tree, BST)是二叉树的一种特例，对于二分查找树的任意节点，该节点储存的数值一定比左子树的所有节点的值大比右子树的所有节点的值小(该节点储存的数值一定比左子树的所有节点的值小比右子树的所有节点的值大)。基于这个特性，二分查找树通常被用于维护有序数据。二分查找树查找、删除、插入的效率都会高于一般的线性数据结构。</p>
<p><img src="http://ww3.sinaimg.cn/mw690/89b29945gw1euxtdkikyyj20bn0azjro.jpg" alt="bst"></p>
<p>平衡二叉树的概念。所谓平衡二叉树，是指一棵树的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p>
<p>###有序数组变为二分查找树</p>
<p>代码示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;num, <span class="keyword">int</span> first, <span class="keyword">int</span> last)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(first &gt; last)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (first == last) &#123;</span><br><span class="line">        TreeNode* parent = <span class="keyword">new</span> TreeNode(num[first]);</span><br><span class="line">        <span class="keyword">return</span> parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (first + last) / <span class="number">2</span>;</span><br><span class="line">    TreeNode *leftchild = helper(num, first, mid - <span class="number">1</span>);</span><br><span class="line">    TreeNode *rightchild = helper(num, mid + <span class="number">1</span>, last);</span><br><span class="line">    TreeNode *parent = <span class="keyword">new</span> TreeNode(num[mid]);</span><br><span class="line">    parent-&gt;left = leftchild;</span><br><span class="line">    parent-&gt;right = rightchild;</span><br><span class="line">    <span class="keyword">return</span> parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode *<span class="title">sortedArrayToBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num.size() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(num.size() == <span class="number">1</span>)&#123;</span><br><span class="line">        TreeNode* parent = <span class="keyword">new</span> TreeNode(num[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> first = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> last = (<span class="keyword">int</span>)num.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> helper(num, first, last);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Is_Binary_Search_Tree">Is Binary Search Tree</h3><p>错误例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/************</span><br><span class="line">    10  </span><br><span class="line">    / \  </span><br><span class="line">    5 15  </span><br><span class="line">      / \  </span><br><span class="line">     6  20  </span><br><span class="line">*************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;left&amp;&amp;!root-&gt;right)</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root-&gt;left)&amp;&amp;(root-&gt;val&gt;root-&gt;left-&gt;val);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!root-&gt;left&amp;&amp;root-&gt;right)</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root-&gt;right)&amp;&amp;(root-&gt;val&lt;root-&gt;right-&gt;val);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;left&amp;&amp;root-&gt;right)</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root-&gt;left)&amp;&amp;isValidBST(root-&gt;right)&amp;&amp;(root-&gt;val&gt;root-&gt;left-&gt;val)&amp;&amp;(root-&gt;val&lt;root-&gt;right-&gt;val);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正确示例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(TreeNode *root, <span class="keyword">int</span> min, <span class="keyword">int</span> max)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>((root-&gt;val &lt; max || (root-&gt;val == INT_MAX &amp;&amp; root-&gt;right == <span class="literal">NULL</span>)) &amp;&amp;</span><br><span class="line">        (root-&gt;val &gt; min || (root-&gt;val == INT_MIN &amp;&amp; root-&gt;left == <span class="literal">NULL</span>)) &amp;&amp;</span><br><span class="line">        helper(root-&gt;left, min, root-&gt;val) &amp;&amp;</span><br><span class="line">        helper(root-&gt;right, root-&gt;val, max))</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> helper(root, INT_MIN, INT_MAX);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Trie">Trie</h2><p>字典树(trie or prefix tree)是一个26(26个英文字母)叉树，用于在一个集合中检索一个字符串，或者字符串前缀。字典树的每个节点有一个指针数组代表其所有子树，其本质上是一个hash table，因为子树所在的位置(index)本身，就代表了节点对应的字母。节点与每个兄弟具有相同的前缀，也被称为prefix tree。</p>
<h3 id="Trie_Structure">Trie Structure</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> TrieNode&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T mContent;</span><br><span class="line">    <span class="built_in">vector</span>&lt;TrieNode*&gt; mChildren;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Node();</span><br><span class="line">    ~Node();</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> Trie;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Trie&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Trie();</span><br><span class="line">    ~Trie();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addWord</span><span class="params">(<span class="built_in">string</span> s)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchWord</span><span class="params">(<span class="built_in">string</span> s)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteWord</span><span class="params">(<span class="built_in">string</span> s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TrieNode* root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Mock_Interview">Mock Interview</h2><h3 id="Lowest_Common_Ancestor(LCA)">Lowest Common Ancestor(LCA)</h3><p>最近的公共衔接点</p>
<p>Given a binary tree and two nodes. Find the lowest common ancestor of the two nodes in the tree.<br>For example, the LCA of D &amp; E is B.</p>
<p><img src="http://ww2.sinaimg.cn/mw690/89b29945gw1euxubtf12ej205g06d74a.jpg" alt="lca"></p>
<p>示例代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">TreeNode *<span class="title">commonAncestor</span><span class="params">(TreeNode *root, TreeNode *p, TreeNode *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (covers(root-&gt;left, p) &amp;&amp; covers(root-&gt;left, q)) &#123;</span><br><span class="line">        <span class="keyword">return</span> commonAncestor(root-&gt;left, q, p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (covers(root-&gt;right, p) &amp;&amp; covers(root-&gt;right, q)) &#123;</span><br><span class="line">        <span class="keyword">return</span> commonAncestor(root-&gt;right, q, p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">covers</span><span class="params">(TreeNode *root, TreeNode *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root == p) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> covers(root-&gt;left, p) || covers(root-&gt;right, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bottom to top</span></span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode *<span class="title">lowestCommonAncestor</span><span class="params">(TreeNode *root, TreeNode *A, TreeNode *B)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// return either A or B or NULL</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == root || root == A || root == B) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        TreeNode *left = lowestCommonAncestor(root-&gt;left, A, B);</span><br><span class="line">        TreeNode *right = lowestCommonAncestor(root-&gt;right, A, B);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// A and B are on both sides</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="literal">NULL</span> != left) &amp;&amp; (<span class="literal">NULL</span> != right)) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// either left or right or NULL</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">NULL</span> != left) ? left : right;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Homework:">Homework:</h2><p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</p>
<p>For example, this binary tree is symmetric:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/************</span><br><span class="line">     1  </span><br><span class="line">   /   \  </span><br><span class="line">  2     2  </span><br><span class="line"> / \   / \  </span><br><span class="line">3   4 4   3  </span><br><span class="line"></span><br><span class="line">************/</span></span><br></pre></td></tr></table></figure>
<p>But the following is not:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********</span><br><span class="line">  1  </span><br><span class="line"> / \  </span><br><span class="line"> 2  2  </span><br><span class="line">  \  \  </span><br><span class="line">   3  3  </span><br><span class="line"></span><br><span class="line">**********/</span></span><br></pre></td></tr></table></figure>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="www.wyiren.com/2015/09/16/算法/3_3/" data-id="cienkyz0c0000ccnut6ek9tm2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/极客班/">极客班</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-算法/2_2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/09/16/算法/2_2/" class="article-date">
  <time datetime="2015-09-16T08:07:45.499Z" itemprop="datePublished">2015-09-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/16/算法/2_2/">2.2 二分搜索模板及变体（下）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="矩阵搜索升级版">矩阵搜索升级版</h2><p>这个代码很巧妙，相比原来的那个<a href="https://github.com/Alvin-yeats/Algorithm_GeekBand/blob/master/chapter2/2_1.md#矩阵搜索" target="_blank" rel="external">矩阵搜索</a>更像是真正意义上的二分查找，亮点就是upper值得初始化和数组下标迭代更新。</p>
<p>实验了下发现董飞老师的示例代码是错误的，while循环内matrix下标应为“[mid/n][mid%n]”，而非“[mid%m][mid%n]”  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Start typing your Java solution below</span></span><br><span class="line">        <span class="comment">// DO NOT write main() function</span></span><br><span class="line">        <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (target &lt; matrix[<span class="number">0</span>][<span class="number">0</span>] || target &gt; matrix[m-<span class="number">1</span>][n-<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> lower = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> upper = m*n -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (lower &lt;= upper) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = lower + (upper-lower)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (target == matrix[mid/n][mid%n]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; matrix[mid/n][mid%n]) &#123;</span><br><span class="line">                upper = mid-<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lower = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Find_Peak_Element">Find Peak Element</h2><p><a href="https://leetcode.com/problems/find-peak-element/" target="_blank" rel="external">原题地址</a><br>A peak element is an element that is greater than its neighbors.<br>For example, in array [1, 2, 3, 1], 3 is a peak element and your function should return the index number 2.</p>
<p>找到数组中的峰点，即这个数大于左右两边的数，示例代码如下。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// A divide and conquer solution to find a peak element element</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A binary search based function that returns index of a peak element</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findPeakUtil</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">// Find index of middle element</span></span><br><span class="line">    <span class="keyword">int</span> mid = low + (high - low)/<span class="number">2</span>;  <span class="comment">/* (low + high)/2 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compare middle element with its neighbours (if neighbours exist)</span></span><br><span class="line">    <span class="keyword">if</span> ((mid == <span class="number">0</span> || arr[mid-<span class="number">1</span>] &lt;= arr[mid]) &amp;&amp;</span><br><span class="line">            (mid == n-<span class="number">1</span> || arr[mid+<span class="number">1</span>] &lt;= arr[mid]))</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If middle element is not peak and its left neighbor is greater than it</span></span><br><span class="line">    <span class="comment">// then left half must have a peak element</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mid &gt; <span class="number">0</span> &amp;&amp; arr[mid-<span class="number">1</span>] &gt; arr[mid])</span><br><span class="line">        <span class="keyword">return</span> findPeakUtil(arr, low, (mid -<span class="number">1</span>), n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If middle element is not peak and its right neighbor is greater than it</span></span><br><span class="line">    <span class="comment">// then right half must have a peak element</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> findPeakUtil(arr, (mid + <span class="number">1</span>), high, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A wrapper over recursive function findPeakUtil()</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findPeak</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> findPeakUtil(arr, <span class="number">0</span>, n-<span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Driver program to check above functions */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">20</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Index of a peak point is %d"</span>, findPeak(arr, n));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="www.wyiren.com/2015/09/16/算法/2_2/" data-id="cienkyz17000hccnu7jb7kyfk" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/极客班/">极客班</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-算法/3_2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/09/16/算法/3_2/" class="article-date">
  <time datetime="2015-09-16T08:07:45.483Z" itemprop="datePublished">2015-09-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/16/算法/3_2/">3.2 分治算法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="https://zh.wikipedia.org/wiki/%E5%88%86%E6%B2%BB%E6%B3%95" target="_blank" rel="external">分治算法</a>是将一个大问题分成几个小问题来进行处理</p>
<h2 id="Divide_&amp;_Conquer_Algorithm">Divide &amp; Conquer Algorithm</h2><ul>
<li>Merge Sort</li>
<li>Quick Sort</li>
<li>Most of the Binary Tree Problems!</li>
</ul>
<h3 id="Tree_Depth">Tree Depth</h3><p>Compute the depth of a binary tree.比较左右两边的深度</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">treeDepth</span><span class="params">(TreeNode *node)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> max(treeDepth(node-&gt;left),treeDepth(node-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Subtree">Subtree</h3><p>Tree1 and Tree2 are both binary trees nodes having value, determine if Tree2 is a subtree of Tree1.<br>判断root2是不是root1的子树</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">subTree</span><span class="params">(TreeNode *root1, TreeNode *root2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root2 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root1 == <span class="literal">NULL</span>) &#123; <span class="comment">//we have exhauste the root1 already</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root1-&gt;val == root2-&gt;val) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matchTree(root1, root2)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isSubTree(root1-&gt;left, root2) || isSubTree(root1-&gt;right, root2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">matchTree</span><span class="params">(TreeNode *root1, TreeNode *root2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root1 == <span class="literal">NULL</span> &amp;&amp; root2 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root1 == <span class="literal">NULL</span> || root2 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root1-&gt;val != root2-&gt;val) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> matchTree(root1-&gt;left, root2-&gt;left) &amp;&amp;</span><br><span class="line">        matchTree(root1-&gt;right, root2-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Balanced_Binary_Tree">Balanced Binary Tree</h3><p>Determine if a binary tree is a balanced tree.</p>
<p>一颗二叉树是平衡的，当且仅当左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p>
<p>当node为空的时候，高度为0，当node不为空的时候，高度为左、右子树中高度较高的那个的高度再加1</p>
<p>示例1：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">level</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root ==  <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> max(level(root-&gt;left), level(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root ==  <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> factor = <span class="built_in">abs</span>(level(root-&gt;left) - level(root-&gt;right));</span><br><span class="line">    <span class="keyword">return</span> factor &lt; <span class="number">2</span> &amp;&amp; isBalanced(root-&gt;right) &amp;&amp; isBalanced(root-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//缺点：重复计算较多</span></span><br></pre></td></tr></table></figure>
<p>示例2（改进版）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isBalancedHelper</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> leftHeight = isBalance(root-&gt;left);</span><br><span class="line">    <span class="keyword">if</span> (leftHeight == INBALANCE) &#123;</span><br><span class="line">        <span class="keyword">return</span> INBALANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> rightHeight = isBalance(root-&gt;right);</span><br><span class="line">    <span class="keyword">if</span> (rightHeight == INBALANCE) &#123;</span><br><span class="line">        <span class="keyword">return</span> INBALANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(leftHeight - rightHeight) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> INBALANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max(leftHeight, rightHeight) + <span class="number">1</span>;    <span class="comment">// return height</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalancedTree</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (isBalancedHelper(root) != INBALANCE)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Path_Sum">Path Sum</h3><p>Get all the paths (always starts from the root) in a binary tree, whose sum would be equal to given value.<br>从root开始，寻找路径value之和为给定sum的路径。</p>
<p>解题思路：使用递归，从root开始让sum不断地减去各个路径上节点的value，然后用于下次递归，直到某个节点值正好等于递减后的sum，我们便存储该路径。</p>
<p>示例代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//path：存储我们走过的具体路径</span></span><br><span class="line"><span class="comment">//result：存储符合条件的路径，可含多个</span></span><br><span class="line"><span class="comment">//root：根节点</span></span><br><span class="line"><span class="comment">//sum：给定的求和值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pathSumHelper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;result, TreeNode *root, <span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    path.push_back(root-&gt;val);</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;val == sum)&#123;</span><br><span class="line">        result.push_back(path);</span><br><span class="line">    &#125;</span><br><span class="line">    pathSumHelper(path, result, root-&gt;left, sum - root-&gt;val);</span><br><span class="line">    pathSumHelper(path, result, root-&gt;right, sum - root-&gt;val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; pathSum(TreeNode *root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">    pathSumHelper(path, result, root, sum);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Rebuild_Binary_Tree">Rebuild Binary Tree</h3><p>给你一个前序、中序字符串构建一个二叉树数据结构</p>
<p>示例代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//pstr:前序</span></span><br><span class="line"><span class="comment">//istr:中序</span></span><br><span class="line"><span class="comment">//n:所给字符串的长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// preorder and inorder rebuild</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">rebuild</span><span class="params">(<span class="keyword">char</span> *pstr, <span class="keyword">char</span> *istr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> TreeNode;</span><br><span class="line">    root-&gt;data = *pstr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* iter;</span><br><span class="line">    <span class="keyword">for</span> (iter = istr; iter &lt; istr + n; iter++) &#123;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//当中序遍历到前序首节点时（根节点）意味着找到了分割点</span></span><br><span class="line">        <span class="keyword">if</span> (*iter == *pstr)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k = iter - istr;</span><br><span class="line">    root-&gt;left = rebuild(pstr + <span class="number">1</span>, istr, k);</span><br><span class="line">    root-&gt;right = rebuild(pstr + k + <span class="number">1</span>, iter + <span class="number">1</span>, n - k - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="www.wyiren.com/2015/09/16/算法/3_2/" data-id="cienkyz0r0005ccnurpfxdwql" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/极客班/">极客班</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-算法/1_4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/09/16/算法/1_4/" class="article-date">
  <time datetime="2015-09-16T08:07:45.467Z" itemprop="datePublished">2015-09-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/16/算法/1_4/">1.4 链表介绍与基本操作</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这节就不逼逼那么多了，直接show code，个人感觉自己用代码实现一遍更好</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************</span><br><span class="line"> *	单链表的基本操作</span><br><span class="line"> *	</span><br><span class="line"> *	功能包含：</span><br><span class="line"> *		节点的数据结构，链表遍历，节点的插入，节点的删除，</span><br><span class="line"> *	链表冒泡排序，链表分割，归并排序</span><br><span class="line"> *</span><br><span class="line"> *********************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数据结构</span></span><br><span class="line"><span class="keyword">class</span> node</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">int</span> data;</span><br><span class="line">		node* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//链表遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span> <span class="params">(node* head)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (node* p = head; p != <span class="literal">NULL</span>; p = p-&gt;next)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; p-&gt;data;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLength</span> <span class="params">(node* head)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		head = head-&gt;nex;</span><br><span class="line">		len ++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//插入节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//插入到头部</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertBegin</span> <span class="params">(node*&amp; head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">	node* newNode = <span class="keyword">new</span> node();</span><br><span class="line">	newNode-&gt;data = val;</span><br><span class="line">	newNode-&gt;next = head;</span><br><span class="line"></span><br><span class="line">	head = newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入到尾部</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertEnd</span> <span class="params">(node*&amp; head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">	node* newNode = <span class="keyword">new</span> node();</span><br><span class="line">	newNode-&gt;data = val;</span><br><span class="line">	newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		head = newNode;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		node* p = head;</span><br><span class="line">		<span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">			p = p-&gt;next;</span><br><span class="line">		p-&gt;next = newNode;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在有序表中插入到指定位置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span> <span class="params">(node*&amp; head, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">	node *cur = head, *pre = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">while</span> (cur-&gt;data &lt; num &amp;&amp; pre-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">		pre = cur, cur = cur-&gt;next;</span><br><span class="line"></span><br><span class="line">	node* p = <span class="keyword">new</span> node();</span><br><span class="line">	p-&gt;data = num;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//链表中的数据全部小于num</span></span><br><span class="line">	<span class="keyword">if</span> (cur-&gt;data &lt; num) &#123;</span><br><span class="line">		cur-&gt;next = p;</span><br><span class="line">		p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	<span class="comment">//链表中的数据全部大于num</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (cur == head) &#123;</span><br><span class="line">		p-&gt;next = cur;</span><br><span class="line">		head = p;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//第三种情况：位于首尾之间,插入到previous和current中间</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		pre-&gt;next = p;</span><br><span class="line">		p-&gt;next = cur;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span> <span class="params">(node*&amp; head, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">	node *cur = head, *pre = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">while</span> (cur-&gt;data != num &amp;&amp; cur-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		pre = cur;</span><br><span class="line">		cur = cur-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (cur-&gt;data != num)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Can't Found "</span> &lt;&lt; num &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//删除头节点</span></span><br><span class="line">		<span class="keyword">if</span> (cur == head) &#123;</span><br><span class="line">			head = cur-&gt;next;</span><br><span class="line">			<span class="keyword">delete</span> cur;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//删除非头节点</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			pre-&gt;next = cur-&gt;next;</span><br><span class="line">			<span class="keyword">delete</span> cur;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//经典O(n^2)的冒泡排序算法</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span> <span class="params">(node* head)</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"> 	<span class="keyword">for</span> (node* p = head; p != <span class="literal">NULL</span>; p = p-&gt;next) &#123;</span><br><span class="line"> 		len ++;</span><br><span class="line"> 	&#125; </span><br><span class="line"></span><br><span class="line"> 	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line"> 		node* p = head;</span><br><span class="line"> 		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len - i; j++, p = p-&gt;next) &#123;</span><br><span class="line"> 			<span class="keyword">if</span> (p-&gt;data &gt; p-&gt;next-&gt;data)</span><br><span class="line"> 			&#123;</span><br><span class="line"> 				<span class="keyword">int</span> tem = p-&gt;data;</span><br><span class="line"> 				p-&gt;data = p-&gt;next-&gt;data;</span><br><span class="line"> 				p-&gt;next-&gt;data = tem;</span><br><span class="line"> 			&#125;</span><br><span class="line"></span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">mergesort</span><span class="params">(node *lsit1, node *list2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (list1 == <span class="literal">NULL</span>) <span class="keyword">return</span> list2;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(list2 == <span class="literal">NULL</span>) <span class="keyword">return</span> list1;</span><br><span class="line"></span><br><span class="line">	node *result= <span class="keyword">new</span> node(), *p = result;</span><br><span class="line">	<span class="keyword">while</span> (list1 != <span class="literal">NULL</span> &amp;&amp; list2 != <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">if</span> (list1-&gt;data &lt; list2-&gt;data)</span><br><span class="line">			result-&gt;next = list1, result = list1, list1 = list1-&gt;next;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			result-&gt;next = list2, result = lsit2, list2 = list2-&gt;next;</span><br><span class="line">	<span class="keyword">if</span> (list1 != <span class="literal">NULL</span>)	result-&gt;next = list1;</span><br><span class="line">	<span class="keyword">if</span> (list2 != <span class="literal">NULL</span>)	result-&gt;next = list2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//返回头节点</span></span><br><span class="line">	result = p-&gt;next;</span><br><span class="line">	<span class="keyword">delete</span> p;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//将链表分割为两个链表</span></span><br><span class="line"><span class="comment">//head:原链表</span></span><br><span class="line"><span class="comment">//list1,list2:分割后的两个链表</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(node *head, node *&amp;list1, node *&amp;list2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		list1 = head, list2 = <span class="literal">NULL</span>;		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	node *slow = head, *fast = head-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (fast != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		fast = fast-&gt;next;</span><br><span class="line">		<span class="keyword">if</span> (fast != <span class="literal">NULL</span>)</span><br><span class="line">			fast = fast-&gt;next, slow = slow-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	list1 = head, list2 = slow-&gt;next;</span><br><span class="line">	slow-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//归并排序主函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(node *&amp;head)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) </span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	</span><br><span class="line">	node *list1, *list2;</span><br><span class="line">	split(head, list1, list2);</span><br><span class="line">	mergeSort(list1);</span><br><span class="line">	mergeSort(list2); </span><br><span class="line">	head = mergesort(list1, list2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="www.wyiren.com/2015/09/16/算法/1_4/" data-id="cienkyz17000qccnushkr1f2k" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/极客班/">极客班</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-算法/1_5" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/09/16/算法/1_5/" class="article-date">
  <time datetime="2015-09-16T08:07:45.452Z" itemprop="datePublished">2015-09-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/16/算法/1_5/">1.5 链表常见操作</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>推荐大家看下<a href="http://book.douban.com/subject/3004255/" target="_blank" rel="external">《编程之美》</a>、<a href="http://book.douban.com/subject/25753386/" target="_blank" rel="external">《程序员面试金典》</a><br>还有编程相关网站：<a href="https://leetcode.com/problemset/algorithms/" target="_blank" rel="external">leetcode</a><br>老师讲的很多题其实就是这些书和网站的题</p>
<h2 id="单链表是否存在环？环的入口是什么？">单链表是否存在环？环的入口是什么？</h2><h3 id="是否存在环">是否存在环</h3><p>1) 判断是否存在环：设置快慢指针fast和slow，fast步速为2，slow为1，若最终fast==slow，那么就证明单链表中一定有环。如果没有环的话，fast一定先到达尾节点</p>
<p>2) 简单证明：利用相对运动的概念，以slow为参考点（静止不动），那么fast的步速实际为1，当fast超过slow之后，fast以每步一个节点的速度追赶slow，如果链表有环的话，fast一定会追赶到slow，即fast==slow。</p>
<h3 id="如何找到环的入口">如何找到环的入口</h3><p><img src="http://ww4.sinaimg.cn/mw690/89b29945gw1eurmxod4q0j20eq09tjs5.jpg" alt="第一次相遇"></p>
<p>字母代表的量：  </p>
<ul>
<li>a：链表头结点到环入口的距离  </li>
<li>r：环长</li>
<li>蓝色线：fast指针所走的距离2s  </li>
<li>黑色线：slow指针所走的距离s</li>
</ul>
<p>假设链表总长度为L，且fast与slow相遇时fast已经绕环走了n圈，则有如下关系：</p>
<p>2s = s + n<em>r<br>将s移到左边得：<br>s = n</em>r<br>转换：<br>s = (n-1)<em>r + r = (n-1)</em>r + L-a<br>a+x = (n-1)<em>r + L-a<br>得：<br>a = (n-1)</em>r + L-a-x</p>
<p>由图可知，（L-a-x）为相遇点到环入口点的距离。由上式可知：<br>从链表头到环入口的距离 = （n-1）圈内环循环 + 相遇点到环入口点的距离<br>将r视为周期的话，a与L-a-x在某种意义上是相等的（实际并不一定相等）。<br>那么由此我们便找到了突破点，为了找到环的入口点，在fast与slow相遇时，将slow指针重新指向单链表的头节点，fast仍然留在相遇点，只不过步速降为与slow相同的1，每次循环只经过一个节点，如此，当fast与slow再次相遇时，那个新的相遇点便是我们苦苦寻找的入口点了。</p>
<h3 id="如何知道环的长度">如何知道环的长度</h3><p>纪录下相遇点，让slow与fast从该点开始，再次碰撞所走过的操作数就是环的长度r。  </p>
<h3 id="带环的链表的长度是多少？">带环的链表的长度是多少？</h3><p>通过以上分析我们已经知道了如何求环入口，环长，那么链表长度显然就是两者之和，即：<br>L = a + r</p>
<h2 id="判断两个链表是否相交">判断两个链表是否相交</h2><p>分析问题之前我们要搞清楚链表相交的一些基本概念  </p>
<ul>
<li>明确概念：两个单向链表相交，只能是y型相交，不可能是x型相交。  </li>
<li>分析：有两个链表，La,Lb,设他们的交点设为p，假设在La中，p的前驱为pre_a，后继为next_a,在Lb中，前驱为pre_b,后继为next_b，则<br>pre_a-&gt;next=p,pre_b-&gt;next=p,接下来看后继,p-&gt;next=next_a,p-&gt;next=next_b；那么问题就出来了，一个单链表的next指针只有一个，<br>怎么跑出两个来呢，所以必有next_a==next_b，于是我们得出两个链表相交只能是Y型相交。明确了这个概念，我们再来堆相交问题进行分析。</li>
</ul>
<h3 id="情况一：两个链表都无环">情况一：两个链表都无环</h3><p>1) 问题简化。将链表B接到链表A的后面，如果A、B有交点，则构成一个有环的单链表，而我们刚刚在上面已经讨论了如何判断一个<br>单链表是否有环。<br>2) 若两个链表相交则必为Y型，由此可知两个链表从相交点到尾节点是相同的，我们并不知道他们的相交点位置，但是我们可以遍历得出A、B链表的<br>尾节点，如此，比较他们的尾节点是否相等便可以求证A、B是否相交了。</p>
<h3 id="情况二：链表有环">情况二：链表有环</h3><p>1) 其中一个链表有环，另外一个链表无环。则两个链表不可能相交。（啥？你不知道为啥？自己看看前面的“明确概念”反省吧）</p>
<p>2) 那么有环相交的情况只有当两个链表都有环时才会出现，如果两个有环链表相交，则他们拥有共通的环，即环上任意一个节点都存在于<br>两个链表上。因此，通过判断A链表上的快慢指针相遇点是否也在B链表上便可以得出两个链表是否相交了。</p>
<h2 id="求相交链表的相交点">求相交链表的相交点</h2><p>题目描述：如果两个无环单向链表相交，怎么求出他们相交的第一个节点呢？</p>
<p>分析：采用对齐的思想。计算两个链表的长度 L1 , L2，分别用两个指针 p1 , p2 指向两个链表的头，然后将较长链表的 p1（假设为 p1）向后移动L2 - L1个节点，然后再同时向后移动p1 , p2，直到 p1 = p2。相遇的点就是相交的第一个节点。</p>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="www.wyiren.com/2015/09/16/算法/1_5/" data-id="cienkyz17000nccnu74424uwf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/极客班/">极客班</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
    </nav>
  
</section>
        
          <aside id="sidebar">
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/极客班/">极客班</a><span class="tag-list-count">12</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a><span class="tag-list-count">12</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/极客班/" style="font-size: 20px;">极客班</a> <a href="/tags/算法/" style="font-size: 20px;">算法</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">September 2015</a><span class="archive-list-count">13</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2015/09/17/笔记·杂/hexo使用心得/">hexo使用心得</a>
          </li>
        
          <li>
            <a href="/2015/09/16/算法/1_3/">1.3 工具和经验谈</a>
          </li>
        
          <li>
            <a href="/2015/09/16/算法/1_2/">1.2 面试中的算法模版</a>
          </li>
        
          <li>
            <a href="/2015/09/16/算法/1_1/">1.1 从第一道面试题谈起</a>
          </li>
        
          <li>
            <a href="/2015/09/16/算法/2_3/">2.3 排序数组常见算法</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2015 Alvin Yeats<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>